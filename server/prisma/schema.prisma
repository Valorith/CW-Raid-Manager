generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "windows"]
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id                 String             @id @default(cuid())
  email              String             @unique
  displayName        String
  googleId           String?            @unique
  discordId          String?            @unique
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt
  nickname           String?
  defaultLogFileName String?            @db.VarChar(255)
  admin              Boolean?           @default(false)
  guide              Boolean?           @default(false)
  createdAttendances AttendanceEvent[]  @relation("AttendanceCreator")
  createdLootListEntries GuildLootListEntry[] @relation("LootListCreator")
  characters         Character[]
  createdGuilds      Guild[]            @relation("GuildCreator")
  guildApplications  GuildApplication[]
  guildMemberships   GuildMembership[]
  createdRaids       RaidEvent[]        @relation("RaidCreator")
  createdLootEvents  RaidLootEvent[]    @relation("LootCreator")
  createdRaidSeries  RaidEventSeries[] @relation("RaidSeriesCreator")
  raidSignups        RaidSignup[]
  createdQuestBlueprints QuestBlueprint[] @relation("QuestBlueprintCreator")
  createdQuestBlueprintFolders QuestBlueprintFolder[] @relation("QuestBlueprintFolderCreator")
  questAssignments   QuestAssignment[]
  personalBankCharacters GuildBankCharacter[]
  calendarAvailability CalendarAvailability[]
  npcFavorites         NpcFavorite[]
  accountNotes         AccountNote[] @relation("AccountNoteCreator")
  characterAssociations CharacterAssociation[] @relation("CharacterAssociationCreator")
  characterWatches     CharacterWatch[] @relation("CharacterWatchCreator")
  inboundWebhooks      InboundWebhook[] @relation("InboundWebhookCreator")
  inboundWebhookAssignments InboundWebhookMessage[] @relation("InboundWebhookAssignee")
  webhookMessageReadStatuses WebhookMessageReadStatus[] @relation("WebhookMessageReadStatus")
  webhookMessageStars WebhookMessageStar[] @relation("WebhookMessageStars")
}

model Guild {
  id                   String                   @id @default(cuid())
  name                 String                   @unique
  slug                 String                   @unique
  description          String?
  createdById          String
  createdAt            DateTime                 @default(now())
  updatedAt            DateTime                 @updatedAt
  defaultRaidStartTime String?                  @db.VarChar(5)
  defaultRaidEndTime   String?                  @db.VarChar(5)
  defaultDiscordVoiceUrl String?               @db.VarChar(512)
  discordWidgetServerId String?                @db.VarChar(64)
  discordWidgetTheme   DiscordWidgetTheme?     @default(DARK)
  discordWidgetEnabled Boolean                 @default(false)
  blacklistSpells      Boolean                 @default(false)
  webhookDebugMode     Boolean                 @default(false)
  characters           Character[]
  createdBy            User                     @relation("GuildCreator", fields: [createdById], references: [id])
  applications         GuildApplication[]
  discordWebhooks      GuildDiscordWebhook[]
  lootParserSettings   GuildLootParserSettings?
  lootLists            GuildLootListEntry[]
  members              GuildMembership[]
  raids                RaidEvent[]
  lootEvents           RaidLootEvent[]
  raidSeries           RaidEventSeries[]
  npcKillEvents       RaidNpcKillEvent[]
  npcNotes            GuildNpcNote[]
  guildBankCharacters GuildBankCharacter[]
  questBlueprints    QuestBlueprint[]
  questAssignments   QuestAssignment[]
  questBlueprintFolders QuestBlueprintFolder[]
  calendarAvailability CalendarAvailability[]
  npcDefinitions     NpcDefinition[]
  npcKillRecords     NpcKillRecord[]
  pendingNpcKillClarifications PendingNpcKillClarification[]
  npcFavorites       NpcFavorite[]

  @@index([createdById], map: "Guild_createdById_fkey")
}

model GuildBankCharacter {
  id              String   @id @default(cuid())
  guildId         String
  userId          String?
  name            String
  normalizedName  String
  isPersonal      Boolean  @default(false)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  guild           Guild    @relation(fields: [guildId], references: [id], onDelete: Cascade)
  user            User?    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([guildId, normalizedName, isPersonal, userId])
  @@index([guildId])
  @@index([userId])
}

model GuildDiscordWebhook {
  id                   String   @id @default(cuid())
  guildId              String
  webhookUrl           String?  @db.VarChar(512)
  isEnabled            Boolean  @default(false)
  usernameOverride     String?  @db.VarChar(120)
  avatarUrl            String?  @db.VarChar(512)
  mentionRoleId        String?  @db.VarChar(120)
  eventSubscriptions   Json     @default(dbgenerated("(json_object())"))
  createdAt            DateTime @default(now())
  updatedAt            DateTime @default(now()) @updatedAt
  label                String   @default("Primary Webhook") @db.VarChar(120)
  mentionSubscriptions Json     @default(dbgenerated("(json_object())"))
  guild                Guild    @relation(fields: [guildId], references: [id], onDelete: Cascade)

  @@index([guildId])
}

model GuildMembership {
  id        String    @id @default(cuid())
  guildId   String
  userId    String
  role      GuildRole
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  guild     Guild     @relation(fields: [guildId], references: [id])
  user      User      @relation(fields: [userId], references: [id])

  @@unique([guildId, userId])
  @@index([userId], map: "GuildMembership_userId_fkey")
}

model GuildApplication {
  id        String                 @id @default(cuid())
  guildId   String
  userId    String
  status    GuildApplicationStatus @default(PENDING)
  createdAt DateTime               @default(now())
  updatedAt DateTime               @updatedAt
  guild     Guild                  @relation(fields: [guildId], references: [id], onDelete: Cascade)
  user      User                   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([guildId, userId])
  @@index([userId], map: "GuildApplication_userId_fkey")
}

model Character {
  id                String              @id @default(cuid())
  name              String              @unique
  level             Int
  class             CharacterClass
  archetype         CharacterArchetype?
  userId            String
  guildId           String?
  isMain            Boolean             @default(true)
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  attendanceRecords AttendanceRecord[]
  raidSignups       RaidSignup[]
  guild             Guild?              @relation(fields: [guildId], references: [id])
  user              User                @relation(fields: [userId], references: [id])
  questAssignments  QuestAssignment[]

  @@index([guildId], map: "Characters_guildId_fkey")
  @@index([userId], map: "Characters_userId_fkey")
  @@map("Characters")
}

model RaidEvent {
  id           String            @id @default(cuid())
  guildId      String
  createdById  String
  name         String
  startTime    DateTime
  targetZones  Json
  targetBosses Json
  notes        String?
  discordVoiceUrl String?        @db.VarChar(512)
  isActive     Boolean           @default(true)
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt
  endedAt      DateTime?
  startedAt    DateTime?
  canceledAt   DateTime?
  recurrenceSeriesId String?
  attendance   AttendanceEvent[]
  createdBy    User              @relation("RaidCreator", fields: [createdById], references: [id])
  guild        Guild             @relation(fields: [guildId], references: [id])
  signups      RaidSignup[]
  loot         RaidLootEvent[]
  npcKillEvents RaidNpcKillEvent[]
  recurrenceSeries   RaidEventSeries? @relation(fields: [recurrenceSeriesId], references: [id], onDelete: SetNull)
  pendingNpcKillClarifications PendingNpcKillClarification[]

  @@index([createdById], map: "RaidEvent_createdById_fkey")
  @@index([guildId], map: "RaidEvent_guildId_fkey")
  @@index([recurrenceSeriesId])
}

model RaidEventSeries {
  id        String                  @id @default(cuid())
  guildId   String
  createdById String
  frequency RaidRecurrenceFrequency
  interval  Int                     @default(1)
  endDate   DateTime?
  isActive  Boolean                 @default(true)
  createdAt DateTime                @default(now())
  updatedAt DateTime                @updatedAt
  events    RaidEvent[]
  guild     Guild                   @relation(fields: [guildId], references: [id], onDelete: Cascade)
  createdBy User                    @relation("RaidSeriesCreator", fields: [createdById], references: [id], onDelete: Cascade)

  @@index([guildId])
  @@index([createdById])
}

model GuildLootParserSettings {
  id        String   @id @default(cuid())
  guildId   String   @unique
  patterns  Json     @default(dbgenerated("(json_array())"))
  emoji     String?  @db.VarChar(16)
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt
  guild     Guild    @relation(fields: [guildId], references: [id], onDelete: Cascade)
}

model RaidLootEvent {
  id          String    @id @default(cuid())
  raidId      String
  guildId     String
  itemName    String
  itemId      Int?
  itemIconId  Int?
  looterName  String
  looterClass String?   @db.VarChar(50)
  eventTime   DateTime?
  emoji       String?   @db.VarChar(16)
  note        String?   @db.VarChar(500)
  createdById String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @default(now()) @updatedAt
  createdBy   User?     @relation("LootCreator", fields: [createdById], references: [id])
  guild       Guild     @relation(fields: [guildId], references: [id], onDelete: Cascade)
  raid        RaidEvent @relation(fields: [raidId], references: [id], onDelete: Cascade)

  @@index([createdById], map: "RaidLootEvent_createdById_fkey")
  @@index([guildId])
  @@index([raidId])
}

model GuildNpcNote {
  id                String                   @id @default(cuid())
  guildId           String
  npcName           String                   @db.VarChar(191)
  npcNameNormalized String                   @db.VarChar(191)
  notes             String?                  @db.LongText
  allaLink          String?                  @db.VarChar(512)
  lastEditedById    String?
  lastEditedByName  String?                  @db.VarChar(191)
  deletionRequestedById   String?
  deletionRequestedByName String?            @db.VarChar(191)
  deletionRequestedAt     DateTime?
  createdAt         DateTime                 @default(now())
  updatedAt         DateTime                 @updatedAt
  guild             Guild                    @relation(fields: [guildId], references: [id], onDelete: Cascade)
  spells            GuildNpcNoteSpell[]
  relatedNpcs       GuildNpcNoteAssociation[]

  @@unique([guildId, npcNameNormalized], map: "GuildNpcNote_guild_npc_unique")
  @@index([guildId])
}

model GuildNpcNoteSpell {
  id        String        @id @default(cuid())
  noteId    String
  name      String        @db.VarChar(191)
  allaLink  String        @db.VarChar(512)
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  note      GuildNpcNote  @relation(fields: [noteId], references: [id], onDelete: Cascade)

  @@index([noteId])
}

model GuildNpcNoteAssociation {
  id                String        @id @default(cuid())
  noteId            String
  associatedNpcName String        @db.VarChar(191)
  allaLink          String        @db.VarChar(512)
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  note              GuildNpcNote  @relation(fields: [noteId], references: [id], onDelete: Cascade)

  @@index([noteId])
}

model RaidNpcKillEvent {
  id                String    @id @default(cuid())
  raidId            String
  guildId           String
  npcName           String    @db.VarChar(191)
  npcNameNormalized String    @db.VarChar(191)
  killerName        String?   @db.VarChar(191)
  zoneName          String?   @db.VarChar(191)
  occurredAt        DateTime
  logSignature      String    @db.VarChar(191)
  createdAt         DateTime  @default(now())
  raid              RaidEvent @relation(fields: [raidId], references: [id], onDelete: Cascade)
  guild             Guild     @relation(fields: [guildId], references: [id], onDelete: Cascade)

  @@unique([raidId, logSignature])
  @@index([raidId])
  @@index([guildId])
  @@index([raidId, npcNameNormalized])
}

model RaidSignup {
  id             String         @id @default(cuid())
  raidId         String
  userId         String
  characterId    String
  characterName  String         @db.VarChar(64)
  characterClass CharacterClass
  characterLevel Int?
  isMain         Boolean        @default(false)
  status         SignupStatus   @default(CONFIRMED)
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @default(now()) @updatedAt
  raid           RaidEvent      @relation(fields: [raidId], references: [id], onDelete: Cascade)
  user           User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  character      Character      @relation(fields: [characterId], references: [id], onDelete: Cascade)

  @@unique([raidId, characterId])
  @@index([raidId])
  @@index([userId])
}

model CalendarAvailability {
  id          String             @id @default(cuid())
  userId      String
  guildId     String
  date        DateTime           @db.Date
  status      AvailabilityStatus @default(UNAVAILABLE)
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @default(now()) @updatedAt
  user        User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  guild       Guild              @relation(fields: [guildId], references: [id], onDelete: Cascade)

  @@unique([userId, guildId, date])
  @@index([guildId])
  @@index([userId])
  @@index([guildId, date])
}

model GuildLootListEntry {
  id                 String             @id @default(cuid())
  guildId            String
  type               LootListType
  matchType          LootListMatchType
  itemId             Int?
  itemName           String             @db.VarChar(191)
  itemNameNormalized String             @db.VarChar(191)
  createdById        String?
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @default(now()) @updatedAt
  guild              Guild             @relation(fields: [guildId], references: [id], onDelete: Cascade)
  createdBy          User?             @relation("LootListCreator", fields: [createdById], references: [id])

  @@index([guildId, type], map: "GuildLootListEntry_guild_type_idx")
  @@index([guildId, itemNameNormalized], map: "GuildLootListEntry_name_idx")
  @@unique([guildId, type, itemId], map: "GuildLootListEntry_item_id_unique")
  @@unique([guildId, type, matchType, itemNameNormalized], map: "GuildLootListEntry_name_unique")
}

model AttendanceEvent {
  id          String              @id @default(cuid())
  raidEventId String
  createdById String
  note        String?
  snapshot    Json?
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
  eventType   AttendanceEventType @default(LOG)
  createdBy   User                @relation("AttendanceCreator", fields: [createdById], references: [id])
  raid        RaidEvent           @relation(fields: [raidEventId], references: [id])
  records     AttendanceRecord[]

  @@index([createdById], map: "AttendanceEvent_createdById_fkey")
  @@index([raidEventId], map: "AttendanceEvent_raidEventId_fkey")
}

model AttendanceRecord {
  id                String           @id @default(cuid())
  attendanceEventId String
  characterId       String?
  characterName     String
  level             Int?
  class             CharacterClass?
  groupNumber       Int?
  status            AttendanceStatus @default(PRESENT)
  flags             String?
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  attendanceEvent   AttendanceEvent  @relation(fields: [attendanceEventId], references: [id])
  character         Character?       @relation(fields: [characterId], references: [id])

  @@index([attendanceEventId], map: "AttendanceRecord_attendanceEventId_fkey")
  @@index([characterId], map: "AttendanceRecord_characterId_fkey")
}

model QuestBlueprint {
  id            String                    @id @default(cuid())
  guildId       String
  createdById   String
  title         String                    @db.VarChar(191)
  summary       String?                   @db.VarChar(500)
  visibility    QuestBlueprintVisibility  @default(GUILD)
  isArchived    Boolean                   @default(false)
  metadata      Json                      @default(dbgenerated("(json_object())"))
  lastEditedById   String?
  lastEditedByName String?                 @db.VarChar(191)
  createdAt     DateTime                  @default(now())
  updatedAt     DateTime                  @updatedAt
  folderId      String?
  folderSortOrder Int                     @default(0)
  guild         Guild                     @relation(fields: [guildId], references: [id], onDelete: Cascade)
  createdBy     User                      @relation("QuestBlueprintCreator", fields: [createdById], references: [id], onDelete: Cascade)
  folder        QuestBlueprintFolder?     @relation(fields: [folderId], references: [id], onDelete: SetNull)
  nodes         QuestNode[]
  links         QuestNodeLink[]
  assignments   QuestAssignment[]

  @@index([guildId])
  @@index([createdById])
  @@index([folderId])
}

model QuestBlueprintFolder {
  id           String                     @id @default(cuid())
  guildId      String
  title        String                     @db.VarChar(191)
  iconKey      String?                    @db.VarChar(191)
  type         QuestBlueprintFolderType   @default(CUSTOM)
  systemKey    String?                    @db.VarChar(191)
  sortOrder    Int                        @default(0)
  createdById  String?
  createdAt    DateTime                   @default(now())
  updatedAt    DateTime                   @updatedAt
  guild        Guild                      @relation(fields: [guildId], references: [id], onDelete: Cascade)
  createdBy    User?                      @relation("QuestBlueprintFolderCreator", fields: [createdById], references: [id], onDelete: SetNull)
  blueprints   QuestBlueprint[]

  @@index([guildId], map: "QuestBlueprintFolder_guildId_idx")
  @@unique([guildId, systemKey], map: "QuestBlueprintFolder_system_key_unique")
}

model QuestNode {
  id            String          @id @default(cuid())
  blueprintId   String
  title         String          @db.VarChar(191)
  description   String?         @db.VarChar(1000)
  nodeType      QuestNodeType
  requirements  Json            @default(dbgenerated("(json_object())"))
  metadata      Json            @default(dbgenerated("(json_object())"))
  positionX     Int             @default(0)
  positionY     Int             @default(0)
  sortOrder     Int             @default(0)
  isGroup       Boolean?        @ignore
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  blueprint     QuestBlueprint  @relation(fields: [blueprintId], references: [id], onDelete: Cascade)
  outgoingLinks QuestNodeLink[] @relation("QuestNodeOutgoing")
  incomingLinks QuestNodeLink[] @relation("QuestNodeIncoming")
  progresses    QuestNodeProgress[]

  @@index([blueprintId], map: "QuestNode_blueprintId_idx")
  @@index([nodeType])
}

model QuestNodeLink {
  id           String         @id @default(cuid())
  blueprintId  String
  parentNodeId String
  childNodeId  String
  conditions   Json           @default(dbgenerated("(json_object())"))
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  blueprint    QuestBlueprint @relation(fields: [blueprintId], references: [id], onDelete: Cascade)
  parentNode   QuestNode      @relation("QuestNodeOutgoing", fields: [parentNodeId], references: [id], onDelete: Cascade)
  childNode    QuestNode      @relation("QuestNodeIncoming", fields: [childNodeId], references: [id], onDelete: Cascade)

  @@index([blueprintId])
  @@index([childNodeId])
  @@unique([parentNodeId, childNodeId])
}

model QuestAssignment {
  id              String                 @id @default(cuid())
  blueprintId     String
  guildId         String
  userId          String
  characterId     String?
  status          QuestAssignmentStatus  @default(ACTIVE)
  startedAt       DateTime               @default(now())
  completedAt     DateTime?
  cancelledAt     DateTime?
  lastProgressAt  DateTime?
  progressSummary Json                   @default(dbgenerated("(json_object())"))
  createdAt       DateTime               @default(now())
  updatedAt       DateTime               @updatedAt
  blueprint       QuestBlueprint         @relation(fields: [blueprintId], references: [id], onDelete: Cascade)
  guild           Guild                  @relation(fields: [guildId], references: [id], onDelete: Cascade)
  user            User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  character       Character?             @relation(fields: [characterId], references: [id], onDelete: SetNull)
  progress        QuestNodeProgress[]

  @@index([guildId])
  @@index([userId])
  @@index([blueprintId])
  @@index([characterId])
}

model QuestNodeProgress {
  id            String                  @id @default(cuid())
  assignmentId  String
  nodeId        String
  status        QuestNodeProgressStatus @default(NOT_STARTED)
  isDisabled    Boolean                 @default(false)
  progressCount Int                     @default(0)
  targetCount   Int                     @default(0)
  notes         String?                 @db.VarChar(500)
  startedAt     DateTime?
  completedAt   DateTime?
  updatedAt     DateTime                @updatedAt
  assignment    QuestAssignment         @relation(fields: [assignmentId], references: [id], onDelete: Cascade)
  node          QuestNode               @relation(fields: [nodeId], references: [id], onDelete: Cascade)

  @@unique([assignmentId, nodeId])
  @@index([nodeId])
}

enum GuildApplicationStatus {
  PENDING
  APPROVED
  DENIED
  WITHDRAWN
}

enum GuildRole {
  LEADER
  OFFICER
  RAID_LEADER
  MEMBER
  RECRUIT
  FRIENDS_FAMILY
}

enum CharacterClass {
  BARD
  BEASTLORD
  BERSERKER
  CLERIC
  DRUID
  ENCHANTER
  MAGICIAN
  MONK
  NECROMANCER
  PALADIN
  RANGER
  ROGUE
  SHADOWKNIGHT
  SHAMAN
  WARRIOR
  WIZARD
  UNKNOWN
}

enum QuestBlueprintFolderType {
  CLASS
  CUSTOM
}

enum CharacterArchetype {
  PRIEST
  MELEE
  CASTER
  HYBRID
}

enum DiscordWidgetTheme {
  LIGHT
  DARK
}

enum AttendanceEventType {
  LOG
  START
  END
  RESTART
}

enum AttendanceStatus {
  PRESENT
  ABSENT
  LATE
  BENCHED
}

enum LootListType {
  WHITELIST
  BLACKLIST
}

enum LootListMatchType {
  ITEM_ID
  ITEM_NAME
}

enum RaidRecurrenceFrequency {
  DAILY
  WEEKLY
  MONTHLY
}

enum SignupStatus {
  CONFIRMED
  NOT_ATTENDING
}

enum AvailabilityStatus {
  AVAILABLE
  UNAVAILABLE
}

enum QuestBlueprintVisibility {
  GUILD
  LINK_ONLY
  PRIVATE
}

enum QuestAssignmentStatus {
  ACTIVE
  COMPLETED
  CANCELLED
  PAUSED
}

enum QuestNodeProgressStatus {
  NOT_STARTED
  IN_PROGRESS
  COMPLETED
  BLOCKED
}

enum QuestNodeType {
  DELIVER
  KILL
  LOOT
  SPEAK_WITH
  EXPLORE
  TRADESKILL
  FISH
  FORAGE
  USE
  TOUCH
  GIVE_CASH
}

enum InboundWebhookActionType {
  DISCORD_RELAY
  CRASH_REVIEW
}

enum InboundWebhookMessageStatus {
  RECEIVED
  PROCESSED
  FAILED
}

enum InboundWebhookActionRunStatus {
  SUCCESS
  FAILED
  SKIPPED
  PENDING_REVIEW
}

model InboundWebhook {
  id             String                 @id @default(cuid())
  label          String                 @db.VarChar(120)
  description    String?                @db.VarChar(500)
  isEnabled      Boolean                @default(true)
  token          String                 @db.VarChar(120)
  retentionPolicy Json                 @default(dbgenerated("(json_object())"))
  createdById    String
  createdAt      DateTime               @default(now())
  updatedAt      DateTime               @updatedAt
  lastReceivedAt     DateTime?
  mergeWindowSeconds Int                    @default(10)
  createdBy          User                   @relation("InboundWebhookCreator", fields: [createdById], references: [id], onDelete: Cascade)
  actions            InboundWebhookAction[]
  messages           InboundWebhookMessage[]

  @@index([createdById])
  @@index([createdAt])
}

model InboundWebhookAction {
  id        String                   @id @default(cuid())
  webhookId String
  type      InboundWebhookActionType
  name      String                   @db.VarChar(120)
  isEnabled Boolean                  @default(true)
  config    Json                     @default(dbgenerated("(json_object())"))
  sortOrder Int                      @default(0)
  createdAt DateTime                 @default(now())
  updatedAt DateTime                 @updatedAt
  webhook   InboundWebhook           @relation(fields: [webhookId], references: [id], onDelete: Cascade)
  runs      InboundWebhookActionRun[]

  @@index([webhookId])
  @@index([type])
}

model InboundWebhookMessage {
  id            String                    @id @default(cuid())
  webhookId     String
  receivedAt    DateTime                  @default(now())
  sourceIp      String?                   @db.VarChar(64)
  headers       Json                      @default(dbgenerated("(json_object())"))
  payload       Json                      @default(dbgenerated("(json_object())"))
  rawBody       String?                   @db.LongText
  status        InboundWebhookMessageStatus @default(RECEIVED)
  actionSummary Json?
  assignedAdminId String?
  assignedAt   DateTime?
  archivedAt   DateTime?
  mergedFromIds Json?
  mergedAt     DateTime?
  webhook       InboundWebhook            @relation(fields: [webhookId], references: [id], onDelete: Cascade)
  assignedAdmin User?                     @relation("InboundWebhookAssignee", fields: [assignedAdminId], references: [id], onDelete: SetNull)
  actionRuns    InboundWebhookActionRun[]
  readStatuses  WebhookMessageReadStatus[]
  stars         WebhookMessageStar[]
  labelAssignments WebhookMessageLabelAssignment[]

  @@index([webhookId])
  @@index([receivedAt])
  @@index([status])
  @@index([assignedAdminId])
  @@index([archivedAt])
}

model InboundWebhookActionRun {
  id         String                       @id @default(cuid())
  messageId  String
  actionId   String
  status     InboundWebhookActionRunStatus @default(SUCCESS)
  error      String?                      @db.Text
  result     Json?
  durationMs Int?
  createdAt  DateTime                     @default(now())
  message    InboundWebhookMessage        @relation(fields: [messageId], references: [id], onDelete: Cascade)
  action     InboundWebhookAction         @relation(fields: [actionId], references: [id], onDelete: Cascade)

  @@index([messageId])
  @@index([actionId])
  @@index([createdAt])
}

// Webhook Message Read Status - per-user read tracking
model WebhookMessageReadStatus {
  id        String                @id @default(cuid())
  messageId String
  userId    String
  readAt    DateTime              @default(now())
  message   InboundWebhookMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user      User                  @relation("WebhookMessageReadStatus", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId])
  @@index([userId])
  @@index([messageId])
}

// Webhook Message Stars - per-user starring/flagging
model WebhookMessageStar {
  id        String                @id @default(cuid())
  messageId String
  userId    String
  createdAt DateTime              @default(now())
  message   InboundWebhookMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user      User                  @relation("WebhookMessageStars", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId])
  @@index([userId])
  @@index([messageId])
}

// Webhook Message Labels - global label definitions
model WebhookMessageLabel {
  id          String                          @id @default(cuid())
  name        String                          @unique @db.VarChar(50)
  color       String                          @db.VarChar(7)
  sortOrder   Int                             @default(0)
  createdAt   DateTime                        @default(now())
  updatedAt   DateTime                        @updatedAt
  assignments WebhookMessageLabelAssignment[]
}

// Webhook Message Label Assignments - message-to-label junction
model WebhookMessageLabelAssignment {
  id        String                @id @default(cuid())
  messageId String
  labelId   String
  createdAt DateTime              @default(now())
  message   InboundWebhookMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  label     WebhookMessageLabel   @relation(fields: [labelId], references: [id], onDelete: Cascade)

  @@unique([messageId, labelId])
  @@index([messageId])
  @@index([labelId])
}

// NPC Respawn Tracker Models

model NpcDefinition {
  id                  String                @id @default(cuid())
  guildId             String
  npcName             String                @db.VarChar(191)
  npcNameNormalized   String                @db.VarChar(191)
  zoneName            String?               @db.VarChar(191)
  respawnMinMinutes   Int?
  respawnMaxMinutes   Int?
  isRaidTarget        Boolean               @default(false)
  hasInstanceVersion  Boolean               @default(false)
  contentFlag         String?               @db.VarChar(50)
  notes               String?               @db.LongText
  allaLink            String?               @db.VarChar(512)
  createdById         String?
  createdByName       String?               @db.VarChar(191)
  createdAt           DateTime              @default(now())
  updatedAt           DateTime              @updatedAt
  guild               Guild                 @relation(fields: [guildId], references: [id], onDelete: Cascade)
  killRecords         NpcKillRecord[]
  subscriptions       NpcRespawnSubscription[]
  pendingClarifications PendingNpcKillClarification[]
  respawnNotifications NpcRespawnNotification[]

  @@unique([guildId, npcNameNormalized, zoneName], map: "NpcDefinition_guild_npc_zone_unique")
  @@index([guildId])
}

model NpcKillRecord {
  id              String        @id @default(cuid())
  guildId         String
  npcDefinitionId String
  killedAt        DateTime
  killedByName    String?       @db.VarChar(191)
  killedById      String?
  notes           String?       @db.VarChar(500)
  isInstance      Boolean       @default(false)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  guild           Guild         @relation(fields: [guildId], references: [id], onDelete: Cascade)
  npcDefinition   NpcDefinition @relation(fields: [npcDefinitionId], references: [id], onDelete: Cascade)
  respawnNotifications NpcRespawnNotification[]

  @@index([guildId])
  @@index([npcDefinitionId])
  @@index([guildId, killedAt])
}

model NpcRespawnSubscription {
  id                String        @id @default(cuid())
  npcDefinitionId   String
  userId            String
  notifyMinutes     Int           @default(5)
  isEnabled         Boolean       @default(true)
  isInstanceVariant Boolean       @default(false)
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  npcDefinition     NpcDefinition @relation(fields: [npcDefinitionId], references: [id], onDelete: Cascade)

  @@unique([npcDefinitionId, userId, isInstanceVariant], map: "NpcRespawnSubscription_npcDef_user_variant_key")
  @@index([userId])
}

// NPC Respawn Notification tracking - tracks which Discord notifications have been sent for current respawn cycle
model NpcRespawnNotification {
  id                String         @id @default(cuid())
  npcDefinitionId   String
  isInstanceVariant Boolean        @default(false)
  lastKillRecordId  String?
  windowNotifiedAt  DateTime?
  upNotifiedAt      DateTime?
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt
  npcDefinition     NpcDefinition  @relation(fields: [npcDefinitionId], references: [id], onDelete: Cascade)
  lastKillRecord    NpcKillRecord? @relation(fields: [lastKillRecordId], references: [id], onDelete: SetNull)

  @@unique([npcDefinitionId, isInstanceVariant], map: "NpcRespawnNotification_npcDef_variant_key")
  @@index([npcDefinitionId])
  @@index([lastKillRecordId])
}

// Pending NPC kill clarifications that need user input
model PendingNpcKillClarification {
  id                String    @id @default(cuid())
  guildId           String
  raidId            String?   // Optional - the raid where this kill was detected
  clarificationType String    @db.VarChar(20) // 'instance' or 'zone'
  npcName           String    @db.VarChar(191)
  killedAt          DateTime
  killedByName      String?   @db.VarChar(191)
  // For instance clarification - the single NPC definition that needs instance/overworld choice
  npcDefinitionId   String?
  // For zone clarification - JSON array of {npcDefinitionId, zoneName} options
  zoneOptions       Json?
  createdAt         DateTime  @default(now())
  // Soft-delete tracking - when resolved/dismissed, set these instead of deleting
  // This prevents re-scanning raid logs from recreating actioned clarifications
  resolvedAt        DateTime?
  resolvedById      String?   @db.VarChar(191)
  guild             Guild     @relation(fields: [guildId], references: [id], onDelete: Cascade)
  raidEvent         RaidEvent? @relation(fields: [raidId], references: [id], onDelete: SetNull)
  npcDefinition     NpcDefinition? @relation(fields: [npcDefinitionId], references: [id], onDelete: Cascade)

  @@index([guildId])
  @@index([raidId])
}

// NPC Favorites - user preference for prioritizing NPCs in respawn tracker
model NpcFavorite {
  id                  String   @id @default(cuid())
  userId              String
  guildId             String
  npcNameNormalized   String   @db.VarChar(191)
  isInstanceVariant   Boolean  @default(false)
  createdAt           DateTime @default(now())
  user                User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  guild               Guild    @relation(fields: [guildId], references: [id], onDelete: Cascade)

  @@unique([userId, guildId, npcNameNormalized, isInstanceVariant], map: "NpcFavorite_user_guild_npc_variant_key")
  @@index([userId, guildId])
}

// Money Tracker Settings - configuration for auto-snapshots
model MoneyTrackerSettings {
  id                  String   @id @default("singleton")
  autoSnapshotEnabled Boolean  @default(false)
  snapshotHour        Int      @default(3)  // 0-23 hour in UTC
  snapshotMinute      Int      @default(0)  // 0-59 minute
  lastSnapshotAt      DateTime?
  updatedAt           DateTime @updatedAt
  updatedById         String?
}

// Auto-Link Settings - tracks last run time for auto-link shared IPs feature
model AutoLinkSettings {
  id              String    @id @default("singleton")
  lastRunAt       DateTime?
  lastRunById     String?
  lastRunByName   String?   @db.VarChar(191)
  updatedAt       DateTime  @updatedAt
}

// Money Tracker - daily snapshots of server currency
model MoneySnapshot {
  id                  String   @id @default(cuid())
  snapshotDate        DateTime @db.Date
  // Server totals (all currency converted to copper for precision)
  totalPlatinum       BigInt   @default(0)
  totalGold           BigInt   @default(0)
  totalSilver         BigInt   @default(0)
  totalCopper         BigInt   @default(0)
  // Breakdown by location
  totalPlatinumBank   BigInt   @default(0)
  totalGoldBank       BigInt   @default(0)
  totalSilverBank     BigInt   @default(0)
  totalCopperBank     BigInt   @default(0)
  totalPlatinumCursor BigInt   @default(0)
  totalGoldCursor     BigInt   @default(0)
  totalSilverCursor   BigInt   @default(0)
  totalCopperCursor   BigInt   @default(0)
  // Total in platinum equivalent for graphing (stored as cents to avoid float issues)
  totalPlatinumEquivalent BigInt @default(0)
  // Shared bank platinum (account-level shared plat)
  totalSharedPlatinum BigInt   @default(0)
  // Guild bank platinum (from data_buckets)
  totalGuildBankPlatinum BigInt @default(0)
  // Top characters snapshot (stored as JSON for flexibility)
  topCharacters       Json     @default(dbgenerated("(json_array())"))
  // Top guild banks snapshot (stored as JSON for flexibility)
  // Note: JSON columns can't have default values in older MySQL versions, so nullable
  topGuildBanks       Json?
  // Metadata
  characterCount      Int      @default(0)
  sharedBankCount     Int      @default(0)
  guildBankCount      Int      @default(0)
  createdAt           DateTime @default(now())
  createdById         String?

  @@index([snapshotDate])
}

// Metallurgy Tracker - Daily snapshots for ore counts and weight trends
model MetallurgySnapshot {
  id                String   @id @default(cuid())
  snapshotDate      DateTime @db.Date
  // Total metallurgy weight across all accounts
  totalWeight       Decimal  @default(0) @db.Decimal(10, 2)
  // Number of accounts with metallurgy weight
  accountCount      Int      @default(0)
  // Ore counts (Tier 1)
  tinOreCount       Int      @default(0)
  copperOreCount    Int      @default(0)
  ironOreCount      Int      @default(0)
  // Ore counts (Tier 2)
  zincOreCount      Int      @default(0)
  nickelOreCount    Int      @default(0)
  cobaltOreCount    Int      @default(0)
  // Ore counts (Tier 3)
  manganeseOreCount Int      @default(0)
  tungstenOreCount  Int      @default(0)
  chromiumOreCount  Int      @default(0)
  // Metadata
  createdAt         DateTime @default(now())
  createdById       String?

  @@index([snapshotDate])
}

// Character Admin - Notes tied to EQ accounts
model AccountNote {
  id              String   @id @default(cuid())
  eqAccountId     Int      // References account.id from EQ database
  content         String   @db.Text
  createdById     String
  createdByName   String   @db.VarChar(191)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  createdBy       User     @relation("AccountNoteCreator", fields: [createdById], references: [id], onDelete: Cascade)

  @@index([eqAccountId])
  @@index([createdById])
}

// Character Admin - Manual associations between characters/accounts
model CharacterAssociation {
  id                    String   @id @default(cuid())
  // Source character (from EQ database)
  sourceCharacterId     Int      // References character_data.id from EQ database
  sourceCharacterName   String   @db.VarChar(191)
  // Associated character (from EQ database)
  targetCharacterId     Int      // References character_data.id from EQ database
  targetCharacterName   String   @db.VarChar(191)
  targetAccountId       Int      // References account.id from EQ database
  // Association type: 'direct' (orange) or 'indirect' (yellow)
  associationType       String   @default("indirect") @db.VarChar(20)
  // Source: 'manual' (admin added) or 'auto' (IP sync)
  source                String   @default("manual") @db.VarChar(20)
  // Metadata
  reason                String?  @db.VarChar(500)
  createdById           String
  createdByName         String   @db.VarChar(191)
  createdAt             DateTime @default(now())
  createdBy             User     @relation("CharacterAssociationCreator", fields: [createdById], references: [id], onDelete: Cascade)

  @@unique([sourceCharacterId, targetCharacterId])
  @@index([sourceCharacterId])
  @@index([targetCharacterId])
  @@index([createdById])
}

// Character Watch List - characters flagged for monitoring
model CharacterWatch {
  id                  String   @id @default(cuid())
  eqCharacterId       Int      // References character_data.id from EQ database
  eqCharacterName     String   @db.VarChar(191)
  eqAccountId         Int      // References account.id from EQ database
  createdById         String
  createdByName       String   @db.VarChar(191)
  createdAt           DateTime @default(now())
  createdBy           User     @relation("CharacterWatchCreator", fields: [createdById], references: [id], onDelete: Cascade)

  @@unique([eqCharacterId])
  @@index([eqAccountId])
  @@index([createdById])
}

// Webhook Debug Messages - stores debug webhook messages for cross-process delivery
// Used when cron jobs need to send debug messages to SSE clients connected to web server
model WebhookDebugMessage {
  id            String   @id @default(cuid())
  guildId       String
  event         String   @db.VarChar(100)
  eventLabel    String   @db.VarChar(200)
  webhookLabel  String   @db.VarChar(200)
  payload       Json
  createdAt     DateTime @default(now())

  @@index([guildId, createdAt])
}
