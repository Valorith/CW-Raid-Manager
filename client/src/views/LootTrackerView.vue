<template>
  <section v-if="raid" class="loot-view">
    <header class="section-header">
      <div>
        <h1>Loot Tracker</h1>
        <p class="muted">{{ raid.name }} ‚Ä¢ {{ formatDate(raid.startTime) }}</p>
      </div>
      <div class="header-actions">
        <RouterLink
          class="btn btn--outline"
          :to="{ name: 'RaidDetail', params: { raidId: raid.id } }"
        >
          Back to Raid
        </RouterLink>
        <button
          v-if="canViewParserSettings"
          class="btn btn--outline btn--settings"
          type="button"
          @click="showSettings = true"
        >
          Parser Settings
        </button>
      </div>
    </header>

    <div class="parsing-window" role="status" aria-live="polite">
      <div class="parsing-window__icon">‚è±</div>
      <div class="parsing-window__details">
        <p class="parsing-window__label">Parsing Window</p>
        <p class="parsing-window__range">{{ parsingWindowStart }} ‚Üí {{ parsingWindowEnd }}</p>
        <p class="parsing-window__hint">
          Only log lines inside this window are analyzed when you upload a log.
        </p>
      </div>
      <button
        v-if="canManageLoot"
        class="btn btn--outline btn--small btn--modal-outline parsing-window__button"
        type="button"
        @click="openWindowModal"
      >
        Adjust Time Window
      </button>
      <button
        v-if="canManageLoot"
        class="btn btn--outline btn--small btn--modal-outline parsing-window__button parsing-window__button--debug"
        type="button"
        @click="showDebugConsole = !showDebugConsole"
        :aria-pressed="showDebugConsole"
      >
        <span aria-hidden="true">üîß</span>
        <span class="sr-only">Toggle Debug Console</span>
        <span class="parsing-window__button-text">Debug</span>
      </button>
    </div>

    <div class="parsing-window-spacer" aria-hidden="true"></div>

    <div v-if="monitorSession && lootConsoleVisible" class="loot-console-container">
      <button class="loot-console__suppress" type="button" @click="handleLootConsoleSuppress">
        Suppress
      </button>
      <div class="loot-console-stage">
        <div class="loot-console-background" aria-hidden="true"></div>
        <Transition name="loot-console-transition">
          <div
            v-if="lootConsoleCurrent"
            class="loot-console"
            :class="{
              'loot-console--accepted': lootConsoleCurrent.status === 'ACCEPTED',
              'loot-console--rejected': lootConsoleCurrent.status === 'REJECTED'
            }"
            role="status"
            aria-live="assertive"
          >
            <span class="loot-console__line">{{ lootConsoleCurrent.line }}</span>
          </div>
        </Transition>
      </div>
    </div>

    <div v-if="clearLootPrompt.visible" class="modal-backdrop">
      <div class="modal">
        <header class="modal__header">
          <div>
            <h3>Clear Existing Loot?</h3>
          </div>
          <button class="icon-button" type="button" @click="handleClearLootPromptClose">‚úï</button>
        </header>
        <div class="modal__body">
          <p class="muted small">
            {{
              clearLootPrompt.mode === 'monitor'
                ? 'Live monitoring will continue from the current loot list. Decide whether to reset it before streaming new loot.'
                : 'This upload can replace existing loot entries. Decide whether to clear the current list before parsing.'
            }}
          </p>
          <p class="muted x-small">
            {{ lootEvents.length }}
            existing loot {{ lootEvents.length === 1 ? 'entry' : 'entries' }} will remain if you keep them.
          </p>
        </div>
        <footer class="clear-loot-actions">
          <button
            class="btn btn--outline btn--modal-outline"
            type="button"
            @click="handleClearLootPromptClose"
          >
            Go Back
          </button>
          <button
            class="btn btn--outline btn--modal-outline clear-loot-actions__button--danger"
            type="button"
            @click="handleClearLootPromptDecision(true)"
          >
            Clear Loot &amp; Continue
          </button>
          <button
            class="btn btn--modal-primary clear-loot-actions__button--success"
            type="button"
            @click="handleClearLootPromptDecision(false)"
          >
            Keep Loot &amp; Continue
          </button>
        </footer>
      </div>
    </div>

    <div v-if="showUploadModeModal && pendingUploadFile" class="modal-backdrop">
      <div class="modal modal--wide upload-mode-modal">
        <header class="modal__header">
          <div>
            <h3>Select Upload Mode</h3>
            <p class="muted small">
              {{ pendingUploadFile.name }} ‚Ä¢ {{ formatFileSize(pendingUploadFile.size) }}
            </p>
          </div>
          <button class="icon-button" type="button" @click="closeUploadModeModal">‚úï</button>
        </header>
        <p class="upload-mode-warning">
          <span v-if="lootEvents.length === 0">
            ‚ö†Ô∏è Uploading a log clears existing loot entries for a clean review.
          </span>
          <span v-else>
            ‚ö†Ô∏è Uploading or monitoring a log can clear existing loot. You‚Äôll be asked whether to
            reset the current loot before continuing.
          </span>
        </p>
        <div class="upload-mode-options">
          <article class="upload-mode-card">
            <h4>Upload Once</h4>
            <p class="muted small">
              Parse the selected file a single time. Ideal for historical logs.
            </p>
            <button
              class="upload-mode-button upload-mode-button--primary"
              type="button"
              :disabled="clearingLoot"
              @click="confirmUploadMode('single')"
            >
              <span class="upload-mode-button__icon" aria-hidden="true">üì§</span>
              <span class="upload-mode-button__text">
                <strong>{{ clearingLoot ? 'Clearing‚Ä¶' : 'Upload Log Now' }}</strong>
                <small>One-time upload ‚Ä¢ Manual reviews only</small>
              </span>
            </button>
          </article>
          <article
            class="upload-mode-card"
            :class="{ 'upload-mode-card--disabled': !supportsContinuousMonitoring }"
          >
            <h4>Continuous Monitor</h4>
            <p class="muted small">
              Watch this file for new loot lines and stream them into the review queue in real time.
            </p>
            <p class="muted x-small">
              {{
                canStartContinuousMonitor
                  ? 'This locks uploads for everyone until you stop monitoring.'
                  : 'Select a file via the button above to enable monitoring.'
              }}
            </p>
            <button
              class="upload-mode-button upload-mode-button--outline"
              type="button"
              :disabled="!canStartContinuousMonitor || monitorStarting || clearingLoot"
              @click="confirmUploadMode('monitor')"
            >
              <span class="upload-mode-button__icon" aria-hidden="true">‚è±Ô∏è</span>
              <span class="upload-mode-button__text">
                <strong>
                  {{
                    canStartContinuousMonitor
                      ? clearingLoot
                        ? 'Clearing‚Ä¶'
                        : monitorStarting
                          ? 'Starting‚Ä¶'
                          : 'Start Monitoring'
                      : 'Not Supported'
                  }}
                </strong>
                <small>Streams new loot live ‚Ä¢ Locks other uploads</small>
              </span>
            </button>
          </article>
        </div>
      </div>
    </div>

    <section
      v-if="canManageLoot && monitorSession"
      class="card monitor-card"
      role="status"
      aria-live="polite"
    >
      <div class="monitor-card__status">
        <div class="monitor-card__pulse" aria-hidden="true"></div>
        <div>
          <h2>Live Log Monitoring</h2>
          <p class="monitor-card__user">
            {{
              monitorSession.isOwner
                ? 'You are monitoring this raid log.'
                : `${monitorSession.user.displayName} is monitoring this raid.`
            }}
          </p>
          <p class="monitor-card__file">{{ monitorSession.fileName }}</p>
          <p class="muted x-small">Started {{ formatDate(monitorSession.startedAt) }}</p>
        </div>
      </div>
      <div class="monitor-card__actions">
        <p class="muted small">
          Last update {{ formatRelativeTime(monitorSession.lastHeartbeatAt) }}
        </p>
        <p class="muted small">Log uploads are locked until monitoring stops.</p>
        <button
          v-if="monitorSession.isOwner"
          class="btn btn--danger btn--small"
          type="button"
          :disabled="monitorStopping"
          @click="stopActiveMonitor()"
        >
          {{ monitorStopping ? 'Stopping‚Ä¶' : 'Stop Monitoring' }}
        </button>
        <button
          v-else-if="canForceStopMonitor"
          class="btn btn--danger btn--small"
          type="button"
          :disabled="monitorStopping"
          @click="stopActiveMonitor({ force: true })"
        >
          {{ monitorStopping ? 'Stopping‚Ä¶' : 'Force Stop' }}
        </button>
        <p v-else class="muted x-small">
          Only raid leaders or officers can stop an active monitor.
        </p>
      </div>
    </section>

    <section v-if="canManageLoot && !monitorSession && parsedLoot.length === 0" class="card">
      <header class="card__header">
        <div>
          <h2>Upload Log</h2>
          <p class="muted">Upload an EverQuest log to detect loot drops during this raid.</p>
          <p class="muted x-small">
            After selecting a file you can upload once or start continuous monitoring.
          </p>
        </div>
      </header>
      <div
        class="upload-drop"
        :class="{
          'upload-drop--active': dragActive,
          'upload-drop--disabled': monitorStarting || clearingLoot
        }"
        @dragenter.prevent="dragActive = true"
        @dragover.prevent="dragActive = true"
        @dragleave.prevent="dragActive = false"
        @drop.prevent="handleDrop"
      >
        <p v-if="continuousMonitorError" class="error-text">{{ continuousMonitorError }}</p>
        <div v-if="!parsing" class="upload-drop__prompt">
          <p v-if="supportsContinuousMonitoring">Select a log to upload or monitor.</p>
          <p v-else>Drag a log file here or</p>
          <button
            v-if="supportsContinuousMonitoring"
            class="btn btn--outline btn--small upload-drop__button"
            type="button"
            :disabled="monitorStarting || clearingLoot"
            @click="promptFileSelection"
          >
            <span class="btn__icon">üìÅ</span>
            {{ monitorStarting ? 'Preparing‚Ä¶' : 'Select Log File' }}
          </button>
          <label v-else class="btn btn--outline btn--small upload-drop__button">
            <span class="btn__icon">üìÅ</span>
            Select Log File
            <input
              ref="fileInput"
              class="sr-only"
              type="file"
              accept=".txt,.log"
              :disabled="monitorStarting || clearingLoot"
              @change="handleLegacyFileSelect"
            />
          </label>
          <input
            v-if="supportsContinuousMonitoring"
            ref="fileInput"
            class="sr-only"
            type="file"
            accept=".txt,.log"
            :disabled="monitorStarting || clearingLoot"
            @change="handleLegacyFileSelect"
          />
        </div>
        <p v-else>Parsing log‚Ä¶ {{ parseProgress }}%</p>
        <div v-if="parsing" class="progress">
          <div class="progress__bar" :style="{ width: `${parseProgress}%` }"></div>
        </div>
      </div>
    </section>

    <section class="card">
      <header class="card__header">
        <div>
          <h2>Existing Loot</h2>
          <p class="muted">{{ lootEvents.length }} entries recorded.</p>
        </div>
        <button
          v-if="canManageLoot"
          class="btn btn--outline btn--small btn--add-loot"
          type="button"
          @click="openManualModal"
        >
          <span class="btn__icon">+</span>
          Record Loot
        </button>
      </header>
      <p v-if="lootEvents.length === 0" class="muted">No loot recorded yet.</p>
      <div v-else class="loot-grid">
        <article
          v-for="entry in groupedExistingLoot"
          :key="entry.id"
          class="loot-card"
          role="button"
          tabindex="0"
          @click="handleExistingLootCardClick($event, entry.itemName)"
          @contextmenu.prevent="openLootContextMenu($event, entry)"
          @keyup.enter="handleExistingLootCardKeyEnter($event, entry.itemName)"
        >
          <div class="loot-card__count">{{ entry.count }}√ó</div>
          <header class="loot-card__header">
            <span class="loot-card__emoji">{{ entry.emoji }}</span>
            <div>
              <p class="loot-card__item">{{ entry.itemName }}</p>
              <p class="loot-card__looter">
                <CharacterLink :name="entry.looterName" />
                <span v-if="formatCharacterClassLabel(entry.looterClass)" class="loot-card__looter-class">
                  ({{ formatCharacterClassLabel(entry.looterClass) }})
                </span>
              </p>
            </div>
          </header>
          <span
            v-if="entry.isWhitelisted"
            class="loot-card__badge loot-card__badge--whitelist"
            title="Whitelisted"
            aria-label="Whitelisted item"
          >
            ‚≠ê
          </span>
          <p v-if="entry.note" class="loot-card__note">{{ entry.note }}</p>
          <footer v-if="canDeleteExistingLoot" class="loot-card__actions">
            <button
              class="icon-button icon-button--delete"
              type="button"
              @click.stop="deleteLootGroup(entry)"
              :aria-label="`Delete ${entry.itemName} for ${entry.looterName}`"
            >
              üóëÔ∏è
            </button>
          </footer>
        </article>
      </div>
    </section>

    <div v-if="showSettings" class="modal-backdrop" @click.self="showSettings = false">
      <div class="modal modal--wide detected-modal">
        <header class="modal__header">
          <div>
            <h3>Parser Settings</h3>
            <p class="muted small">
              Describe loot phrases using plain language. We convert them to precise patterns
              automatically.
            </p>
          </div>
          <button class="icon-button" type="button" @click="showSettings = false">‚úï</button>
        </header>
        <form class="settings-form" @submit.prevent="saveParserSettings">
          <div class="settings-form__body">
            <div class="settings-grid">
              <div class="settings-grid__side">
                <section class="settings-section">
                  <h4>General</h4>
                  <label class="form__field">
                    <span>Default Loot Emoji</span>
                    <input v-model="editableSettings.emoji" type="text" maxlength="4" />
                    <small class="muted"
                      >Used when the parser can‚Äôt find a specific emoji for an item.</small
                    >
                  </label>
                </section>

                <section class="settings-section sample-tester">
                  <div>
                    <h4>Try a Log Line</h4>
                    <p class="muted small">
                      Paste a log entry to see how each phrase would parse it.
                    </p>
                  </div>
                  <textarea
                    v-model="sampleLogLine"
                    rows="3"
                    placeholder="[Sun Sep 14 21:36:45 2025] Eye of Eashen has been awarded to Loladin by the Master Looter."
                  ></textarea>
                </section>

                <section class="settings-section placeholder-panel">
                  <div class="placeholder-panel__header">
                    <div>
                      <h4>Placeholders</h4>
                      <p class="muted small">Click to insert into the phrase you‚Äôre editing.</p>
                    </div>
                    <p class="muted x-small">
                      Example: ‚Äú{timestamp} {item} has been awarded to {looter} by the {method}.‚Äù
                    </p>
                  </div>
                  <div class="placeholder-toolbar">
                    <div class="placeholder-toolbar__chips">
                      <button
                        v-for="option in placeholderOptions"
                        :key="option.token"
                        class="placeholder-chip"
                        type="button"
                        @click="appendPlaceholder(option.token)"
                      >
                        <span class="placeholder-chip__token">{{ option.token }}</span>
                        <span class="placeholder-chip__text">{{ option.description }}</span>
                      </button>
                    </div>
                  </div>
                </section>
              </div>

              <div class="settings-grid__main">
                <section class="settings-section">
                  <div class="section-heading section-heading--stacked">
                    <div>
                      <h4>Loot Phrase Builder</h4>
                      <p class="muted small">
                        Describe the exact log line and we‚Äôll handle the complex regex for you.
                      </p>
                    </div>
                    <button
                      class="btn btn--outline btn--small btn--modal-outline"
                      type="button"
                      @click="addPattern()"
                    >
                      <span class="btn__icon">+</span>
                      Add Phrase
                    </button>
                  </div>

                  <div
                    v-if="editableSettings.patterns.length === 0"
                    class="pattern-card pattern-card--empty"
                  >
                    <p>No phrases yet. Start by describing how loot lines look in your logs.</p>
                    <button class="btn btn--small" type="button" @click="addPattern()">
                      Create First Phrase
                    </button>
                  </div>

                  <div v-else class="pattern-list">
                    <article
                      v-for="(pattern, index) in editableSettings.patterns"
                      :key="pattern.id"
                      class="pattern-card"
                      :class="{
                        'pattern-card--active': activePatternIndex === index,
                        'pattern-card--collapsed': collapsedPatternIds[pattern.id]
                      }"
                    >
                      <div class="pattern-card__header">
                        <div class="pattern-card__header-main">
                          <button
                            class="pattern-card__toggle"
                            type="button"
                            @click.stop="togglePatternCollapse(pattern.id)"
                            :aria-expanded="!collapsedPatternIds[pattern.id]"
                            :aria-controls="`pattern-body-${pattern.id}`"
                          >
                            <span
                              class="pattern-card__chevron"
                              :class="{
                                'pattern-card__chevron--rotated': !collapsedPatternIds[pattern.id]
                              }"
                              >‚åÑ</span
                            >
                          </button>
                          <input
                            v-model="pattern.label"
                            type="text"
                            placeholder="Description (e.g. Kael chest drops)"
                            @focus="setActivePattern(index)"
                          />
                        </div>
                        <button
                          class="btn btn--danger btn--small btn--modal-danger"
                          type="button"
                          @click.stop="removePattern(index)"
                        >
                          <span class="btn__icon">√ó</span>
                          Remove
                        </button>
                      </div>
                      <div
                        class="pattern-card__body"
                        :id="`pattern-body-${pattern.id}`"
                        v-show="!collapsedPatternIds[pattern.id]"
                      >
                        <label class="form__field">
                          <span>Plain-language phrase</span>
                          <textarea
                            v-model="pattern.pattern"
                            rows="3"
                            placeholder="{timestamp} {item} has been awarded to {looter} by the {method}."
                            :ref="(el) => setPatternTextareaRef(pattern.id, el)"
                            @focus="handleTextareaFocus(index, pattern.id)"
                            @keyup="updateCaretPosition(pattern.id)"
                            @mouseup="updateCaretPosition(pattern.id)"
                            @click="updateCaretPosition(pattern.id)"
                            @input="updateCaretPosition(pattern.id)"
                          ></textarea>
                        </label>
                        <div class="pattern-card__helper">
                          <span class="pattern-card__helper-label">Includes</span>
                          <div class="pattern-card__helper-content">
                            <template v-if="placeholderUsage(pattern.pattern).length > 0">
                              <span
                                v-for="placeholder in placeholderUsage(pattern.pattern)"
                                :key="placeholder.token"
                                class="pattern-chip"
                              >
                                {{ placeholder.label }}
                              </span>
                            </template>
                            <span v-else class="muted x-small"
                              >Add placeholders like {timestamp}, {item}, {looter}, {method} so we
                              know what to capture.</span
                            >
                          </div>
                        </div>
                        <div class="pattern-preview">
                          <div>
                            <p class="pattern-preview__label">Regex preview</p>
                            <code class="pattern-preview__code">{{
                              patternPreview(pattern.pattern)
                            }}</code>
                          </div>
                          <p class="muted x-small">
                            Sent to the parser automatically‚Äîno regex knowledge required.
                          </p>
                        </div>
                        <div
                          v-if="patternIncludesMethod(pattern.pattern)"
                          class="pattern-method-ignore"
                        >
                          <label class="form__field">
                            <span>Ignore loot methods</span>
                            <div class="method-input">
                              <input
                                v-model="pattern.methodInput"
                                type="text"
                                class="method-input__field"
                                placeholder="Type a method (e.g. Master Looter)"
                                @keyup.enter.prevent="addIgnoredMethod(index)"
                              />
                              <button
                                class="btn btn--outline btn--small"
                                type="button"
                                @click="addIgnoredMethod(index)"
                              >
                                Add
                              </button>
                            </div>
                            <p class="muted x-small">
                              Case-insensitive. Any detected loot using these methods will be
                              discarded automatically.
                            </p>
                          </label>
                          <div v-if="pattern.ignoredMethods.length" class="method-pill-container">
                            <span
                              v-for="method in pattern.ignoredMethods"
                              :key="method"
                              class="method-pill"
                            >
                              <span class="method-pill__label">{{ method }}</span>
                              <button
                                type="button"
                                class="method-pill__remove"
                                @click="removeIgnoredMethod(index, method)"
                                aria-label="Remove ignored method"
                              >
                                √ó
                              </button>
                            </span>
                          </div>
                        </div>
                        <div
                          v-if="sampleLogLine"
                          class="pattern-test"
                          :class="
                            patternSampleResult(pattern).matches
                              ? 'pattern-test--match'
                              : 'pattern-test--miss'
                          "
                        >
                          <template v-if="patternSampleResult(pattern).matches">
                            <p class="pattern-test__header">
                              <span class="pattern-test__status">Matches sample line</span>
                            </p>
                            <ul class="pattern-test__list">
                              <li>
                                <strong>Looter:</strong>
                                <span>{{
                                  patternSampleResult(pattern).looter ?? 'Not captured'
                                }}</span>
                              </li>
                              <li>
                                <strong>Item:</strong>
                                <span>{{
                                  patternSampleResult(pattern).item ?? 'Not captured'
                                }}</span>
                              </li>
                              <li>
                                <strong>Method:</strong>
                                <span>{{
                                  patternSampleResult(pattern).method ?? 'Not captured'
                                }}</span>
                              </li>
                            </ul>
                          </template>
                          <template v-else>
                            <p class="pattern-test__header">
                              <span class="pattern-test__status">
                                {{ patternSampleResult(pattern).reason ?? 'No match for sample' }}
                              </span>
                            </p>
                            <p class="muted x-small" v-if="patternSampleResult(pattern).ignored">
                              Remove this method from the ignored list if you want the parser to
                              capture lines like this.
                            </p>
                            <p class="muted x-small" v-else>
                              Try aligning this phrase with the wording of your log.
                            </p>
                          </template>
                        </div>
                      </div>
                    </article>
                  </div>
                </section>
              </div>
            </div>
          </div>

          <footer class="form__actions">
            <button
              class="btn btn--outline btn--modal-outline"
              type="button"
              @click="showSettings = false"
            >
              Cancel
            </button>
            <button class="btn btn--modal-primary" type="submit" :disabled="updatingSettings">
              {{ updatingSettings ? 'Saving‚Ä¶' : 'Save Settings' }}
            </button>
          </footer>
        </form>
      </div>
    </div>

    <div
      v-if="showLeaveMonitorModal"
      class="modal-backdrop"
      @click.self="dismissLeaveMonitorModal(false)"
    >
      <div class="modal">
        <header class="modal__header">
          <div>
            <h3>Stop Monitoring?</h3>
            <p class="muted small">Navigating away will stop live log monitoring for this raid.</p>
          </div>
          <button class="icon-button" type="button" @click="dismissLeaveMonitorModal(false)">
            ‚úï
          </button>
        </header>
        <p class="muted">
          If you leave this page, live loot parsing will stop and other officers will be able to
          take over monitoring. Are you sure you want to continue?
        </p>
        <footer class="leave-monitor-actions">
          <button
            class="btn leave-monitor-button leave-monitor-button--stay"
            type="button"
            @click="dismissLeaveMonitorModal(false)"
          >
            Stay Here
          </button>
          <button
            class="btn leave-monitor-button leave-monitor-button--leave"
            type="button"
            :disabled="monitorStopping"
            @click="dismissLeaveMonitorModal(true)"
          >
            {{ monitorStopping ? 'Stopping‚Ä¶' : 'Leave Page' }}
          </button>
        </footer>
      </div>
    </div>

    <div v-if="showManualModal" class="modal-backdrop" @click.self="closeManualModal">
      <div class="modal">
        <header class="modal__header">
          <div>
            <h3>Manual Loot Entry</h3>
            <p class="muted small">
              Use this when you want to record a drop without importing a log line.
            </p>
          </div>
          <button class="icon-button" type="button" @click="closeManualModal">‚úï</button>
        </header>
        <form class="manual-form" @submit.prevent="createManualEntry">
          <div class="manual-form__grid">
            <input v-model="manualForm.itemName" type="text" placeholder="Item name" required />
            <input v-model="manualForm.looterName" type="text" placeholder="Looter" required />
            <input v-model="manualForm.looterClass" type="text" placeholder="Class" />
            <input v-model="manualForm.emoji" type="text" placeholder="Emoji" maxlength="4" />
            <textarea v-model="manualForm.note" rows="3" placeholder="Note (optional)"></textarea>
          </div>
          <footer class="form__actions">
            <button class="btn btn--outline" type="button" @click="closeManualModal">Cancel</button>
            <button class="btn" type="submit" :disabled="manualSaving">
              {{ manualSaving ? 'Adding‚Ä¶' : 'Add Loot' }}
            </button>
          </footer>
        </form>
      </div>
    </div>

    <div v-if="editLootModal.visible" class="modal-backdrop">
      <div class="modal">
        <header class="modal__header">
          <div>
            <h3>Edit Loot Entry</h3>
            <p class="muted small">Update the assignee or quantity for this loot drop.</p>
          </div>
          <button class="icon-button" type="button" :disabled="editLootModal.saving" @click="closeEditLootModal">
            ‚úï
          </button>
        </header>
        <form class="edit-loot-form" @submit.prevent="saveEditedLoot">
          <label class="form__field">
            <span>Item</span>
            <input
              type="text"
              :value="editLootModal.entry?.itemName ?? ''"
              disabled
            />
          </label>
          <label class="form__field">
            <span>Assigned To</span>
            <input
              v-model="editLootModal.form.looterName"
              type="text"
              required
              :disabled="editLootModal.saving"
            />
          </label>
          <label class="form__field">
            <span>Quantity</span>
            <input
              v-model.number="editLootModal.form.count"
              type="number"
              min="1"
              required
              :disabled="editLootModal.saving"
            />
          </label>
          <footer class="form__actions">
            <button
              class="btn btn--outline btn--modal-outline"
              type="button"
              :disabled="editLootModal.saving"
              @click="closeEditLootModal"
            >
              Cancel
            </button>
            <button class="btn btn--modal-primary" type="submit" :disabled="editLootModal.saving">
              {{ editLootModal.saving ? 'Saving‚Ä¶' : 'Save Changes' }}
            </button>
          </footer>
        </form>
      </div>
    </div>

    <div v-if="showWindowModal" class="modal-backdrop" @click.self="closeWindowModal">
      <div class="modal">
        <header class="modal__header">
          <div>
            <h3>Adjust Parsing Window</h3>
            <p class="muted small">
              This only affects log parsing and will not change the raid‚Äôs actual schedule.
            </p>
          </div>
          <button class="icon-button" type="button" @click="closeWindowModal">‚úï</button>
        </header>
        <form class="window-form" @submit.prevent="saveParsingWindow">
          <label class="form__field">
            <span>Start Date &amp; Time</span>
            <input v-model="parsingWindowForm.start" type="datetime-local" required />
          </label>
          <label class="form__field">
            <span>End Date &amp; Time</span>
            <input v-model="parsingWindowForm.end" type="datetime-local" />
            <small class="muted"
              >Leave blank to parse until the end of the uploaded log file.</small
            >
          </label>
          <div class="window-form__controls">
            <button
              class="btn btn--outline btn--small btn--modal-outline"
              type="button"
              @click="resetWindowToRaidTimes"
            >
              Reset to Raid Times
            </button>
            <div class="window-form__actions">
              <button
                class="btn btn--outline btn--modal-outline"
                type="button"
                @click="closeWindowModal"
              >
                Cancel
              </button>
              <button class="btn btn--modal-primary" type="submit">Save Window</button>
            </div>
          </div>
        </form>
      </div>
    </div>

    <section v-if="canManageLoot && showDebugConsole" class="card debug-console">
      <header class="card__header">
        <h2>Debug Console</h2>
        <div class="debug-console__actions">
          <button
            class="btn btn--outline btn--small"
            type="button"
            :disabled="debugLogs.length === 0"
            @click="copyDebugLogs"
          >
            Copy Logs
          </button>
          <button
            class="btn btn--outline btn--small"
            type="button"
            :disabled="debugLogs.length === 0"
            @click="debugLogs = []"
          >
            Clear
          </button>
        </div>
      </header>
      <div class="debug-console__body">
        <p v-if="debugLogs.length === 0" class="muted small">No debug output yet.</p>
        <ul v-else class="debug-console__list">
          <li v-for="entry in debugLogs" :key="entry.id" class="debug-console__entry">
            <div>
              <p class="debug-console__timestamp">
                {{ formatDate(entry.timestamp.toISOString()) }}
              </p>
              <p class="debug-console__message">{{ entry.message }}</p>
            </div>
            <pre v-if="entry.context" class="debug-console__context">{{
              formatContext(entry.context)
            }}</pre>
          </li>
        </ul>
      </div>
    </section>

    <div v-if="detectedLootModalOpen" class="modal-backdrop">
      <div class="modal modal--wide">
        <header class="modal__header">
          <div>
            <h3>Detected Loot</h3>
            <p class="muted small">Review each drop before adding it to the raid log.</p>
          </div>
          <button class="icon-button" type="button" @click="showDetectedModal = false">‚úï</button>
        </header>
        <div class="detected-controls">
          <button
            class="btn detected-control detected-control--keep"
            type="button"
            @click="setAllKept(true)"
          >
            üü¢ Keep All
          </button>
          <button
            class="btn detected-control detected-control--discard"
            type="button"
            @click="setAllKept(false)"
          >
            üî¥ Discard All
          </button>
        </div>
        <div class="detected-table-wrapper">
          <table class="loot-table">
            <thead>
              <tr>
                <th>Disposition</th>
                <th>Time</th>
                <th>Looter</th>
                <th>Item</th>
              </tr>
            </thead>
            <tbody>
              <tr
                v-for="row in paginatedParsedLoot"
                :key="row.id"
                :class="{
                  'loot-table__row--discarded':
                    row.disposition === 'DISCARD' || row.disposition === 'BLACKLIST'
                }"
              >
                <td>
                  <div class="disposition-buttons">
                    <button
                      v-for="option in dispositionOptions"
                      :key="option.value"
                      type="button"
                      class="disposition-button"
                      :class="{
                        'disposition-button--selected': row.disposition === option.value,
                        'disposition-button--keep': option.value === 'KEEP',
                        'disposition-button--discard': option.value === 'DISCARD',
                        'disposition-button--whitelist': option.value === 'WHITELIST',
                        'disposition-button--blacklist': option.value === 'BLACKLIST'
                      }"
                      :disabled="option.requiresManage && !canManageLootLists"
                      @click="handleDispositionChange(row, option.value)"
                    >
                      <span class="disposition-button__icon">{{ option.icon }}</span>
                      <span class="disposition-button__label">{{ option.label }}</span>
                    </button>
                  </div>
                </td>
                <td>{{ row.timestamp ? formatDate(row.timestamp.toISOString()) : '‚Äî' }}</td>
                <td>
                  <input v-model="row.looterName" type="text" />
                </td>
                <td>
                  <input v-model="row.itemName" type="text" />
                </td>
              </tr>
            </tbody>
          </table>
          <div v-if="parsedLootTotalPages > 1" class="pagination pagination--detected">
            <button
              class="pagination__button"
              type="button"
              :disabled="parsedLootPage === 1"
              @click="parsedLootPage -= 1"
            >
              Previous
            </button>
            <span class="pagination__label"
              >Page {{ parsedLootPage }} of {{ parsedLootTotalPages }}</span
            >
            <button
              class="pagination__button"
              type="button"
              :disabled="parsedLootPage === parsedLootTotalPages"
              @click="parsedLootPage += 1"
            >
              Next
            </button>
          </div>
        </div>
        <footer class="form__actions form__actions--single">
          <button
            class="btn detected-save-button"
            type="button"
            :disabled="savingLoot"
            @click="saveParsedLoot"
          >
            {{ savingLoot ? 'Saving‚Ä¶' : 'Save' }}
          </button>
        </footer>
      </div>
    </div>
    <div
      v-if="lootContextMenu.visible"
      class="loot-context-menu"
      :style="{ top: `${lootContextMenu.y}px`, left: `${lootContextMenu.x}px` }"
      @contextmenu.prevent
      @click.stop
    >
      <header class="loot-context-menu__header">{{ lootContextMenu.itemName }}</header>
      <button
        v-if="canDeleteExistingLoot"
        class="loot-context-menu__action"
        type="button"
        @click="handleEditLootClick"
      >
        Edit Loot‚Ä¶
      </button>
      <button
        v-if="canDeleteExistingLoot"
        class="loot-context-menu__action loot-context-menu__action--remove"
        type="button"
        @click="handleRemoveLootClick"
      >
        Remove
      </button>
      <button
        v-if="!lootContextMenu.whitelistEntry"
        class="loot-context-menu__action"
        type="button"
        @click="addItemToLootList('WHITELIST')"
      >
        Add to Whitelist
      </button>
      <button
        v-else
        class="loot-context-menu__action loot-context-menu__action--remove"
        type="button"
        @click="removeItemFromLootList('WHITELIST')"
      >
        Remove from Whitelist
      </button>
      <button
        v-if="!lootContextMenu.blacklistEntry"
        class="loot-context-menu__action"
        type="button"
        @click="addItemToLootList('BLACKLIST')"
      >
        Add to Blacklist
      </button>
      <button
        v-else
        class="loot-context-menu__action loot-context-menu__action--remove"
        type="button"
        @click="removeItemFromLootList('BLACKLIST')"
      >
        Remove from Blacklist
      </button>
    </div>
  </section>
  <p v-else class="muted">Loading raid‚Ä¶</p>
</template>

<script setup lang="ts">
import { computed, nextTick, onBeforeUnmount, onMounted, reactive, ref, watch } from 'vue';
import CharacterLink from '../components/CharacterLink.vue';
import { RouterLink, useRoute, useRouter, onBeforeRouteLeave } from 'vue-router';

import {
  api,
  type GuildLootParserSettings,
  type GuildLootListEntry,
  type GuildLootListSummary,
  type RaidDetail,
  type RaidLootEvent,
  type RaidLogMonitorSession
} from '../services/api';
import { characterClassLabels, type CharacterClass } from '../services/types';
import {
  parseLootLog,
  type GuildLootParserPattern,
  type ParsedLootEvent
} from '../services/lootParser';
import { useAuthStore } from '../stores/auth';
import {
  convertPlaceholdersToRegex,
  convertRegexToPlaceholders
} from '../utils/patternPlaceholders';
import {
  buildLootListLookup,
  matchesLootListEntry,
  normalizeLootItemName
} from '../utils/lootLists';

type DetectedLootDisposition = 'KEEP' | 'DISCARD' | 'WHITELIST' | 'BLACKLIST';

interface ParsedRow {
  id: string;
  timestamp: Date | null;
  rawLine: string;
  itemName: string;
  itemId: number | null;
  looterName: string;
  emoji: string;
  disposition: DetectedLootDisposition;
}

interface DebugLogEntry {
  id: number;
  timestamp: Date;
  message: string;
  context?: Record<string, unknown>;
}

interface GroupedLootEntry {
  id: string;
  itemName: string;
  looterName: string;
  looterClass?: string | null;
  emoji: string;
  note?: string | null;
  count: number;
  eventIds: string[];
  isWhitelisted: boolean;
}

type HandlePermissionDescriptor = {
  mode?: 'read' | 'readwrite';
};

type LocalFileHandle = {
  kind: 'file';
  name: string;
  getFile: () => Promise<File>;
  requestPermission?: (descriptor?: HandlePermissionDescriptor) => Promise<PermissionState>;
  queryPermission?: (descriptor?: HandlePermissionDescriptor) => Promise<PermissionState>;
};

type LootConsoleStatus = 'ACCEPTED' | 'REJECTED';

interface LootConsoleItem {
  id: string;
  line: string;
  status: LootConsoleStatus;
}

interface LootConsolePayload {
  line: string;
  status: LootConsoleStatus;
}

const route = useRoute();
const router = useRouter();
const raidId = route.params.raidId as string;

const raid = ref<RaidDetail | null>(null);
const lootEvents = ref<RaidLootEvent[]>([]);
const parserSettings = ref<GuildLootParserSettings | null>(null);
const parsedLoot = ref<ParsedRow[]>([]);
const parsing = ref(false);
const parseProgress = ref(0);
const dragActive = ref(false);
const savingLoot = ref(false);
const manualSaving = ref(false);
const showSettings = ref(false);
const showManualModal = ref(false);
const showWindowModal = ref(false);
const showDebugConsole = ref(false);
const showDetectedModal = ref(false);
const parsedLootPage = ref(1);
const detectedLootModalOpen = computed(
  () => showDetectedModal.value && parsedLoot.value.length > 0
);
const PAGE_SIZE = 10;
const parsedLootTotalPages = computed(() =>
  Math.max(1, Math.ceil(parsedLoot.value.length / PAGE_SIZE))
);
const paginatedParsedLoot = computed(() => {
  const total = parsedLootTotalPages.value;
  const currentPage = Math.min(parsedLootPage.value, total);
  const start = (currentPage - 1) * PAGE_SIZE;
  return parsedLoot.value.slice(start, start + PAGE_SIZE);
});

const showLeaveMonitorModal = ref(false);
type PendingNavigation = { type: 'route'; to: any } | { type: 'refresh' };

const pendingNavigation = ref<PendingNavigation | null>(null);
const allowImmediateUnload = ref(false);
const updatingSettings = ref(false);
type EditablePattern = GuildLootParserPattern & { ignoredMethods: string[]; methodInput: string };

interface PatternSampleResult {
  matches: boolean;
  looter?: string;
  item?: string;
  method?: string;
  ignored?: boolean;
  reason?: string;
  error?: string;
}

const editableSettings = reactive<{
  patterns: EditablePattern[];
  emoji: string;
}>({ patterns: [], emoji: 'üíé' });
const activePatternIndex = ref<number | null>(null);
const collapsedPatternIds = ref<Record<string, boolean>>({});
const patternTextareas = ref<Record<string, HTMLTextAreaElement | null>>({});
const patternCaretPositions = ref<Record<string, { start: number; end: number }>>({});
const sampleLogLine = ref('');
const manualForm = reactive({
  itemName: '',
  looterName: '',
  looterClass: '',
  emoji: 'üíé',
  note: ''
});
const parsingWindow = reactive<{ start: string | null; end: string | null }>({
  start: null,
  end: null
});
const parsingWindowForm = reactive({
  start: '',
  end: ''
});
const debugLogs = ref<DebugLogEntry[]>([]);
const authStore = useAuthStore();
let lootAudioContext: AudioContext | null = null;
const showUploadModeModal = ref(false);
const pendingUploadFile = ref<File | null>(null);
const monitorSession = ref<RaidLogMonitorSession | null>(null);
const monitorHeartbeatInterval = ref(10_000);
const monitorTimeoutMs = ref(30_000);
const monitorStarting = ref(false);
const monitorStopping = ref(false);
const monitorStatusPollId = ref<number | null>(null);
const continuousMonitorError = ref<string | null>(null);
const monitorController = reactive({
  fileHandle: null as LocalFileHandle | null,
  lastSize: 0,
  pendingFragment: '',
  pollTimerId: null as number | null,
  heartbeatTimerId: null as number | null,
  fileSignature: null as string | null
});
const processedLogKeys = new Set<string>();
const activeLogSignature = ref<string | null>(null);
const PROCESSED_LOG_STORAGE_PREFIX = 'cw-raid-processed-log';
let liveChunkInFlight = false;
const lootConsoleQueue = ref<LootConsoleItem[]>([]);
const lootConsoleCurrent = ref<LootConsoleItem | null>(null);
const lootConsoleTimerId = ref<number | null>(null);
const lootConsoleCooldownId = ref<number | null>(null);
const lootConsoleVisible = computed(
  () => lootConsoleCurrent.value !== null || lootConsoleQueue.value.length > 0
);
const supportsContinuousMonitoring = computed(
  () => typeof window !== 'undefined' && typeof (window as any).showOpenFilePicker === 'function'
);
const pendingFileHandle = ref<LocalFileHandle | null>(null);
const canStartContinuousMonitor = computed(
  () => supportsContinuousMonitoring.value && pendingFileHandle.value !== null
);
const clearingLoot = ref(false);
const clearLootPrompt = reactive<{
  visible: boolean;
  mode: 'single' | 'monitor';
  resolve: ((result: boolean | null) => void) | null;
}>({
  visible: false,
  mode: 'single',
  resolve: null
});
const editLootModal = reactive<{
  visible: boolean;
  entry: GroupedLootEntry | null;
  form: {
    looterName: string;
    itemName: string;
    count: number;
  };
  saving: boolean;
}>({
  visible: false,
  entry: null,
  form: {
    looterName: '',
    itemName: '',
    count: 1
  },
  saving: false
});

function normalizeLogFileName(value?: string | null) {
  if (!value) {
    return 'unknown-log';
  }
  const normalized = value.trim().toLowerCase();
  return normalized || 'unknown-log';
}

function buildLogSignature(fileName?: string | null) {
  return `${raidId}::${normalizeLogFileName(fileName)}`;
}

function storageKeyForSignature(signature: string) {
  return `${PROCESSED_LOG_STORAGE_PREFIX}:${signature}`;
}

function loadStoredProcessedKeys(signature: string) {
  if (typeof window === 'undefined' || !window.localStorage) {
    return [] as string[];
  }
  try {
    const raw = window.localStorage.getItem(storageKeyForSignature(signature));
    if (!raw) {
      return [];
    }
    const parsed = JSON.parse(raw);
    const entries = Array.isArray(parsed)
      ? parsed
      : Array.isArray(parsed?.entries)
        ? parsed.entries
        : [];
    return entries.filter(
      (entry: unknown): entry is string => typeof entry === 'string' && entry.length > 0
    );
  } catch {
    return [];
  }
}

function persistStoredProcessedKeys(signature: string) {
  if (typeof window === 'undefined' || !window.localStorage) {
    return;
  }
  try {
    const entries = Array.from(processedLogKeys);
    window.localStorage.setItem(storageKeyForSignature(signature), JSON.stringify(entries));
  } catch {
    // Ignore persistence issues (e.g., storage quota exceeded)
  }
}

function clearStoredProcessedKeys(signature: string) {
  if (typeof window === 'undefined' || !window.localStorage) {
    return;
  }
  try {
    window.localStorage.removeItem(storageKeyForSignature(signature));
  } catch {
    // Ignore storage errors
  }
}

function clearStoredProcessedLogsForRaid() {
  if (typeof window === 'undefined' || !window.localStorage) {
    return;
  }
  const prefix = `${PROCESSED_LOG_STORAGE_PREFIX}:${raidId}::`;
  const toRemove: string[] = [];
  for (let index = 0; index < window.localStorage.length; index += 1) {
    const key = window.localStorage.key(index);
    if (key && key.startsWith(prefix)) {
      toRemove.push(key);
    }
  }
  for (const key of toRemove) {
    try {
      window.localStorage.removeItem(key);
    } catch {
      // Ignore storage errors
    }
  }
}

function activateProcessedLogSignature(signature: string | null, reset: boolean) {
  if (!signature) {
    return;
  }
  const shouldReload = reset || activeLogSignature.value !== signature;
  if (shouldReload) {
    processedLogKeys.clear();
    const stored = loadStoredProcessedKeys(signature);
    for (const key of stored) {
      processedLogKeys.add(key);
    }
  }
  activeLogSignature.value = signature;
}

function persistActiveProcessedLogState() {
  if (!activeLogSignature.value) {
    return;
  }
  persistStoredProcessedKeys(activeLogSignature.value);
}

function resetProcessedLogState(options?: { clearStorage?: boolean; signature?: string | null }) {
  if (options?.clearStorage) {
    if (options.signature) {
      clearStoredProcessedKeys(options.signature);
    } else {
      clearStoredProcessedLogsForRaid();
    }
  }
  processedLogKeys.clear();
  if (options?.signature !== undefined) {
    activeLogSignature.value = options.signature;
  } else {
    activeLogSignature.value = null;
  }
}
watch(
  () => [raid.value?.startTime, raid.value?.endedAt],
  ([start, end]) => {
    if (start && !parsingWindow.start) {
      parsingWindow.start = start;
    }
    if (end && !parsingWindow.end) {
      parsingWindow.end = end;
    }
  }
);

watch(
  () => monitorSession.value,
  (session) => {
    if (!session) {
      clearLootConsole();
    }
  }
);
watch(
  () => monitorSession.value?.isOwner ?? false,
  (isOwner, wasOwner) => {
    if (!isOwner && wasOwner) {
      cleanupMonitorController();
    }
  }
);
watch(detectedLootModalOpen, (open) => {
  if (open) {
    window.addEventListener('keydown', handleDetectedModalKeydown);
  } else {
    window.removeEventListener('keydown', handleDetectedModalKeydown);
  }
});
const placeholderOptions = [
  {
    token: '{timestamp}',
    label: 'Timestamp',
    description: 'Matches the leading [Day Mon DD HH:MM:SS YYYY] text.'
  },
  {
    token: '{item}',
    label: 'Item',
    description: 'The item name pulled from the log line.'
  },
  {
    token: '{looter}',
    label: 'Recipient',
    description: 'The character who received the loot.'
  },
  {
    token: '{method}',
    label: 'Loot method',
    description: 'How the item was awarded (Master Looter, random roll, Loot Council, etc.).'
  }
];

const dispositionOptions: Array<{
  value: DetectedLootDisposition;
  label: string;
  icon: string;
  requiresManage?: boolean;
}> = [
  { value: 'KEEP', label: 'Keep', icon: 'üü¢' },
  { value: 'DISCARD', label: 'Discard', icon: 'üî¥' },
  { value: 'WHITELIST', label: 'Whitelist', icon: '‚≠ê', requiresManage: true },
  { value: 'BLACKLIST', label: 'Blacklist', icon: '‚õî', requiresManage: true }
];

const defaultRegexPatterns: GuildLootParserPattern[] = [
  {
    id: 'default-master-method',
    label: 'Awarded by Master Looter / Loot Council',
    pattern: convertPlaceholdersToRegex(
      '{timestamp} {item} has been awarded to {looter} by the {method}.'
    ),
    ignoredMethods: []
  },
  {
    id: 'default-random-roll',
    label: 'Awarded by random roll',
    pattern: convertPlaceholdersToRegex(
      '{timestamp} {item} has been awarded to {looter} by {method}.'
    ),
    ignoredMethods: []
  },
  {
    id: 'default-donation',
    label: 'Donations to guild',
    pattern: convertPlaceholdersToRegex(
      "{timestamp} {item} has been donated to the Master Looter's guild."
    ),
    ignoredMethods: []
  }
];

const fileInput = ref<HTMLInputElement | null>(null);

const lootListSummary = ref<GuildLootListSummary | null>(null);
const whitelistLookup = computed(() => buildLootListLookup(lootListSummary.value?.whitelist ?? []));
const blacklistLookup = computed(() => buildLootListLookup(lootListSummary.value?.blacklist ?? []));
const canManageLootLists = computed(() => {
  const role = raid.value?.permissions?.role;
  return role === 'LEADER' || role === 'OFFICER' || role === 'RAID_LEADER';
});
const canManageLoot = computed(() => raid.value?.permissions?.canManage ?? false);
const canViewParserSettings = computed(() => {
  const role = raid.value?.permissions?.role;
  return role === 'LEADER' || role === 'OFFICER';
});
const lootContextMenu = reactive({
  visible: false,
  x: 0,
  y: 0,
  itemName: '',
  itemId: null as number | null,
  normalizedName: '',
  whitelistEntry: null as GuildLootListEntry | null,
  blacklistEntry: null as GuildLootListEntry | null,
  entry: null as GroupedLootEntry | null
});
const canDeleteExistingLoot = computed(() => {
  const role = raid.value?.permissions?.role;
  return role === 'LEADER' || role === 'OFFICER' || role === 'RAID_LEADER';
});
const canForceStopMonitor = computed(() => canDeleteExistingLoot.value);
const groupedExistingLoot = computed<GroupedLootEntry[]>(() => {
  const whitelistLookupValue = whitelistLookup.value;
  const grouped = new Map<string, GroupedLootEntry>();
  for (const event of lootEvents.value) {
    const key = `${event.looterName}::${event.itemName}`;
    if (!grouped.has(key)) {
      grouped.set(key, {
        id: event.id,
        itemName: event.itemName,
        looterName: event.looterName,
        looterClass: event.looterClass,
        emoji: event.emoji ?? parserSettings.value?.emoji ?? 'üíé',
        note: event.note,
        count: 0,
        eventIds: [],
        isWhitelisted: false
      });
    }
    const entry = grouped.get(key)!;
    entry.count += 1;
    entry.eventIds.push(event.id);
  }
  return Array.from(grouped.values())
    .map((entry) => {
      const normalized = normalizeLootItemName(entry.itemName);
      return {
        ...entry,
        isWhitelisted: Boolean(matchesLootListEntry(whitelistLookupValue, null, normalized))
      };
    })
    .sort((a, b) => b.count - a.count);
});
const parsingWindowStart = computed(() => {
  const { earlier } = resolveWindowBounds();
  return earlier ? formatDate(earlier) : 'Unknown start';
});
const parsingWindowEnd = computed(() => {
  const { later } = resolveWindowBounds();
  if (!later) {
    return 'Current time (log end)';
  }
  return formatDate(later);
});
const monitorLockActive = computed(() => Boolean(monitorSession.value));

async function loadData() {
  raid.value = await api.fetchRaid(raidId);
  lootEvents.value = await api.fetchRaidLoot(raidId);
  await refreshLootListSummary();
  const guildSettings = await api.fetchGuildLootSettings(raid.value.guild.id);
  syncEditableParserSettings(guildSettings);
  resetManualForm();
  initializeParsingWindow();
  await fetchMonitorStatus();
  startMonitorStatusPolling();
}

async function refreshLootListSummary() {
  if (!raid.value) {
    return;
  }

  if (!canManageLootLists.value) {
    lootListSummary.value = null;
    return;
  }

  try {
    lootListSummary.value = await api.fetchGuildLootListSummary(raid.value.guild.id);
  } catch (error) {
    lootListSummary.value = null;
    appendDebugLog('Failed to load loot list summary', { error: String(error) });
  }
}

function openLootContextMenu(event: MouseEvent, entry: GroupedLootEntry) {
  if (!canManageLootLists.value) {
    return;
  }
  event.preventDefault();
  const normalizedName = normalizeLootItemName(entry.itemName);
  const whitelistEntry = matchesLootListEntry(whitelistLookup.value, null, normalizedName);
  const blacklistEntry = matchesLootListEntry(blacklistLookup.value, null, normalizedName);
  const menuWidth = 220;
  const menuHeight = 160;
  const x = Math.min(event.clientX, window.innerWidth - menuWidth);
  const y = Math.min(event.clientY, window.innerHeight - menuHeight);
 Object.assign(lootContextMenu, {
    visible: true,
    x,
    y,
    itemName: entry.itemName,
    itemId: null,
    normalizedName,
    whitelistEntry,
    blacklistEntry,
    entry
  });
}

function closeLootContextMenu() {
  lootContextMenu.visible = false;
}

function handleEditLootClick() {
  if (!lootContextMenu.entry) {
    return;
  }
  openEditLootModal(lootContextMenu.entry);
  closeLootContextMenu();
}

function handleRemoveLootClick() {
  if (!lootContextMenu.entry) {
    return;
  }
  const entry = lootContextMenu.entry;
  closeLootContextMenu();
  void deleteLootGroup(entry, { skipConfirm: true });
}

function handleGlobalPointerDown(event: MouseEvent) {
  if (!lootContextMenu.visible) {
    return;
  }
  const target = event.target as HTMLElement | null;
  if (target && target.closest('.loot-context-menu')) {
    return;
  }
  if (event.type === 'contextmenu' && target && target.closest('.loot-card')) {
    return;
  }
  closeLootContextMenu();
}

function handleLootContextMenuKey(event: KeyboardEvent) {
  if (event.key === 'Escape' && lootContextMenu.visible) {
    closeLootContextMenu();
  }
}

function openEditLootModal(entry: GroupedLootEntry) {
  editLootModal.entry = entry;
  editLootModal.form.looterName = entry.looterName;
  editLootModal.form.count = entry.count;
  editLootModal.visible = true;
  editLootModal.saving = false;
}

function closeEditLootModal(force = false) {
  if (!force && editLootModal.saving) {
    return;
  }
  editLootModal.visible = false;
  editLootModal.entry = null;
  editLootModal.form.looterName = '';
  editLootModal.form.count = 1;
  editLootModal.saving = false;
}

async function fetchMonitorStatus() {
  try {
    const status = await api.fetchRaidLogMonitorStatus(raidId);
    monitorHeartbeatInterval.value = status.heartbeatIntervalMs ?? monitorHeartbeatInterval.value;
    monitorTimeoutMs.value = status.timeoutMs ?? monitorTimeoutMs.value;
    monitorSession.value = status.session ?? null;
    if (!status.session) {
      cleanupMonitorController();
    } else if (status.session.isOwner && status.session.sessionId) {
      startMonitorHeartbeat();
    }
  } catch (error) {
    appendDebugLog('Failed to load log monitor status', { error: String(error) });
  }
}

function startMonitorStatusPolling() {
  stopMonitorStatusPolling();
  monitorStatusPollId.value = window.setInterval(() => {
    if (monitorSession.value?.isOwner) {
      return;
    }
    fetchMonitorStatus();
  }, 8000);
}

function stopMonitorStatusPolling() {
  if (monitorStatusPollId.value) {
    window.clearInterval(monitorStatusPollId.value);
    monitorStatusPollId.value = null;
  }
}

async function promptFileSelection() {
  if (monitorLockActive.value || clearingLoot.value) {
    return;
  }

  if (!supportsContinuousMonitoring.value) {
    fileInput.value?.click();
    return;
  }

  try {
    const handle = await requestPersistentFileHandle();
    if (!handle) {
      return;
    }
    await ensureHandlePermission(handle);
    const file = await handle.getFile();
    setPendingUploadSelection(file, { handle, reason: 'picker' });
  } catch (error) {
    appendDebugLog('File picker cancelled or failed', { error: String(error) });
  }
}

function handleLegacyFileSelect(event: Event) {
  const target = event.target as HTMLInputElement;
  const file = target.files?.[0] ?? null;
  target.value = '';
  if (!file) {
    appendDebugLog('File selection cleared or empty');
    return;
  }

  if (monitorLockActive.value) {
    appendDebugLog('File selection ignored because monitoring is active');
    return;
  }

  if (clearingLoot.value) {
    appendDebugLog('File selection ignored while raid loot is clearing');
    return;
  }

  setPendingUploadSelection(file, { handle: null, reason: 'legacy-input' });
}

function handleDrop(event: DragEvent) {
  const file = event.dataTransfer?.files?.[0];
  dragActive.value = false;
  if (!file) {
    return;
  }
  if (monitorLockActive.value) {
    appendDebugLog('File drop ignored because monitoring is active');
    return;
  }
  if (clearingLoot.value) {
    appendDebugLog('File drop ignored while raid loot is clearing');
    return;
  }
  if (supportsContinuousMonitoring.value) {
    appendDebugLog(
      'Drag-and-drop disabled when continuous monitoring is available. Use Select Log File instead.'
    );
    window.alert('Please use Select Log File to enable continuous monitoring.');
    return;
  }
  setPendingUploadSelection(file, { handle: null, reason: 'drag-drop' });
}

function setPendingUploadSelection(
  file: File,
  options: { handle: LocalFileHandle | null; reason: string }
) {
  pendingUploadFile.value = file;
  pendingFileHandle.value = options.handle;
  showUploadModeModal.value = true;
  appendDebugLog('File selected', {
    name: file.name,
    size: file.size,
    source: options.reason,
    hasHandle: Boolean(options.handle)
  });
}

async function clearExistingLootBeforeUpload() {
  if (!raid.value) {
    return;
  }
  try {
    await api.clearRaidLoot(raidId);
    lootEvents.value = [];
    parsedLoot.value = [];
    showDetectedModal.value = false;
    resetProcessedLogState({ clearStorage: true });
    appendDebugLog('Existing loot cleared prior to new upload');
  } catch (error) {
    appendDebugLog('Failed to clear existing loot before upload', { error: String(error) });
    throw error;
  }
}

function closeUploadModeModal() {
  showUploadModeModal.value = false;
  pendingUploadFile.value = null;
  pendingFileHandle.value = null;
}

async function confirmUploadMode(mode: 'single' | 'monitor') {
  const file = pendingUploadFile.value;
  if (!file) {
    showUploadModeModal.value = false;
    return;
  }

  showUploadModeModal.value = false;

  let shouldClear = true;
  if (lootEvents.value.length > 0) {
    const decision = await promptClearExistingLoot(mode);
    if (decision === null) {
      showUploadModeModal.value = true;
      return;
    }
    shouldClear = decision;
    appendDebugLog('Existing loot prompt answered', {
      mode,
      chosenAction: shouldClear ? 'clear-loot' : 'keep-loot',
      existingLootCount: lootEvents.value.length
    });
  }

  await proceedUploadMode(mode, { file, shouldClear });
}

function promptClearExistingLoot(mode: 'single' | 'monitor') {
  return new Promise<boolean | null>((resolve) => {
    clearLootPrompt.visible = true;
    clearLootPrompt.mode = mode;
    clearLootPrompt.resolve = resolve;
  });
}

function handleClearLootPromptDecision(shouldClear: boolean) {
  resolveClearLootPrompt(shouldClear);
}

function handleClearLootPromptClose() {
  resolveClearLootPrompt(null);
  showUploadModeModal.value = true;
}

function resolveClearLootPrompt(result: boolean | null) {
  const resolver = clearLootPrompt.resolve;
  clearLootPrompt.visible = false;
  clearLootPrompt.resolve = null;
  if (resolver) {
    resolver(result);
  }
}

async function proceedUploadMode(
  mode: 'single' | 'monitor',
  options: { file: File; shouldClear: boolean }
) {
  const { file, shouldClear } = options;
  const signature = buildLogSignature(file.name);

  if (shouldClear) {
    try {
      clearingLoot.value = true;
      await clearExistingLootBeforeUpload();
    } catch (error) {
      appendDebugLog('Unable to clear existing loot before upload', { error: String(error) });
      window.alert('Unable to clear existing loot for this raid. Please try again.');
      showUploadModeModal.value = true;
      return;
    } finally {
      clearingLoot.value = false;
    }
  }

  if (mode === 'single') {
    continuousMonitorError.value = null;
    await readLogFile(file, {
      append: !shouldClear,
      resetKeys: shouldClear,
      signature
    });
    pendingUploadFile.value = null;
    pendingFileHandle.value = null;
    return;
  }

  if (!pendingFileHandle.value) {
    window.alert(
      'Continuous monitoring requires selecting the file via the Select Log File button.'
    );
    showUploadModeModal.value = true;
    pendingUploadFile.value = file;
    return;
  }

  await startContinuousMonitor(file, pendingFileHandle.value);
  pendingUploadFile.value = null;
  pendingFileHandle.value = null;
}

async function saveEditedLoot() {
  if (!raid.value || !editLootModal.entry) {
    return;
  }
  const newLooter = editLootModal.form.looterName.trim();
  const newCount = Number(editLootModal.form.count);
  if (!newLooter) {
    window.alert('Looter name is required.');
    return;
  }
  if (!Number.isFinite(newCount) || newCount < 1) {
    window.alert('Quantity must be at least 1.');
    return;
  }

  const entry = editLootModal.entry;
  const currentCount = entry.count;
  const countDiff = newCount - currentCount;
  const emoji = entry.emoji ?? parserSettings.value?.emoji ?? 'üíé';

  editLootModal.saving = true;
  try {
    if (newLooter !== entry.looterName) {
      await Promise.all(
        entry.eventIds.map((lootId) =>
          api.updateRaidLoot(raidId, lootId, { looterName: newLooter })
        )
      );
    }

    if (countDiff > 0) {
      const payload = Array.from({ length: countDiff }, () => ({
        itemName: entry.itemName,
        looterName: newLooter,
        emoji,
        note: entry.note ?? undefined
      }));
      await api.createRaidLoot(raidId, payload);
    } else if (countDiff < 0) {
      const removeIds = entry.eventIds.slice(entry.eventIds.length + countDiff);
      await Promise.all(removeIds.map((lootId) => api.deleteRaidLoot(raidId, lootId)));
    }

    lootEvents.value = await api.fetchRaidLoot(raidId);
    await refreshLootListSummary();
    appendDebugLog('Loot entry edited', {
      itemName: entry.itemName,
      previousCount: currentCount,
      newCount,
      previousLooter: entry.looterName,
      newLooter
    });
    window.dispatchEvent(
      new CustomEvent('loot-updated', {
        detail: {
          title: 'Loot Updated',
          message: `${entry.itemName} now assigned to ${newLooter} (${newCount}√ó)`
        }
      })
    );
    closeEditLootModal(true);
  } catch (error) {
    appendDebugLog('Failed to edit loot entry', { error: String(error) });
    window.alert('Unable to update loot entry. Please try again.');
  } finally {
    editLootModal.saving = false;
  }
}

async function startContinuousMonitor(initialFile: File, providedHandle?: LocalFileHandle | null) {
  if (monitorSession.value) {
    appendDebugLog('Continuous monitoring skipped: session already active');
    return;
  }
  if (!supportsContinuousMonitoring.value) {
    continuousMonitorError.value = 'This browser does not support continuous monitoring.';
    appendDebugLog('Continuous monitoring blocked: unsupported browser');
    return;
  }

  monitorStarting.value = true;
  continuousMonitorError.value = null;
  let sessionStarted = false;

  try {
    const handle = providedHandle ?? (await requestPersistentFileHandle());
    if (!handle) {
      appendDebugLog('Continuous monitoring cancelled before selecting a file');
      return;
    }

    await ensureHandlePermission(handle);

    const status = await api.startRaidLogMonitor(raidId, {
      fileName: handle.name ?? initialFile.name
    });
    monitorHeartbeatInterval.value = status.heartbeatIntervalMs ?? monitorHeartbeatInterval.value;
    monitorTimeoutMs.value = status.timeoutMs ?? monitorTimeoutMs.value;
    monitorSession.value = status.session ?? null;
    sessionStarted = Boolean(status.session);

    if (!monitorSession.value) {
      throw new Error('Unable to start monitoring session.');
    }

    monitorController.fileHandle = handle;
    monitorController.lastSize = initialFile.size;
    monitorController.pendingFragment = '';
    monitorController.fileSignature = buildLogSignature(handle.name ?? initialFile.name);

    startMonitorHeartbeat();
    await readLogFile(initialFile, {
      append: false,
      resetKeys: false,
      signature: monitorController.fileSignature
    });
    startLiveLogPolling();
    appendDebugLog('Continuous monitoring enabled', {
      file: handle.name,
      sessionId: monitorSession.value.sessionId
    });
  } catch (error) {
    continuousMonitorError.value =
      error instanceof Error ? error.message : 'Unable to enable continuous monitoring.';
    appendDebugLog('Continuous monitoring failed', { error: String(error) });
    if (sessionStarted && monitorSession.value?.sessionId) {
      await api.stopRaidLogMonitor(raidId, { sessionId: monitorSession.value.sessionId });
    }
    monitorSession.value = null;
    cleanupMonitorController();
  } finally {
    monitorStarting.value = false;
  }
}

async function requestPersistentFileHandle() {
  const picker = typeof window !== 'undefined' ? (window as any).showOpenFilePicker : null;
  if (typeof picker !== 'function') {
    throw new Error('Continuous monitoring requires a Chromium-based browser.');
  }

  try {
    const handles = await picker({
      multiple: false,
      excludeAcceptAllOption: false,
      types: [
        {
          description: 'EverQuest Logs',
          accept: {
            'text/plain': ['.txt', '.log']
          }
        }
      ]
    });
    return Array.isArray(handles) && handles.length > 0 ? (handles[0] as LocalFileHandle) : null;
  } catch (error) {
    if (error instanceof DOMException && error.name === 'AbortError') {
      return null;
    }
    throw error;
  }
}

async function ensureHandlePermission(handle: LocalFileHandle) {
  if (typeof handle.queryPermission === 'function') {
    const current = await handle.queryPermission({ mode: 'read' });
    if (current === 'granted') {
      return;
    }
    if (current === 'denied') {
      throw new Error('Read permission denied for the selected log file.');
    }
  }
  if (typeof handle.requestPermission === 'function') {
    const result = await handle.requestPermission({ mode: 'read' });
    if (result !== 'granted') {
      throw new Error('Continuous monitoring requires read access to the log file.');
    }
  }
}

function startLiveLogPolling() {
  stopLiveLogPolling();
  if (!monitorSession.value?.isOwner || !monitorController.fileHandle) {
    return;
  }
  monitorController.pollTimerId = window.setInterval(() => {
    void readLiveLogChunk();
  }, 2000);
}

function stopLiveLogPolling() {
  if (monitorController.pollTimerId) {
    window.clearInterval(monitorController.pollTimerId);
    monitorController.pollTimerId = null;
  }
}

async function readLiveLogChunk() {
  if (!monitorController.fileHandle || !monitorSession.value?.isOwner || liveChunkInFlight) {
    return;
  }
  liveChunkInFlight = true;
  try {
    const file = await monitorController.fileHandle.getFile();
    if (file.size < monitorController.lastSize) {
      monitorController.lastSize = 0;
      monitorController.pendingFragment = '';
    }
    if (file.size === monitorController.lastSize) {
      return;
    }
    const blob = file.slice(monitorController.lastSize);
    const text = await blob.text();
    monitorController.lastSize = file.size;
    const chunk = drainMonitorChunk(text);
    if (!chunk.trim()) {
      return;
    }
    const startIso = parsingWindow.start ?? raid.value?.startTime ?? new Date().toISOString();
    const endIso = parsingWindow.end ?? raid.value?.endedAt ?? null;
    const start = new Date(startIso);
    const end = endIso ? new Date(endIso) : undefined;
    activateProcessedLogSignature(monitorController.fileSignature, false);
    processLogContent(chunk, { append: true, resetKeys: false, start, end });
    persistActiveProcessedLogState();
  } catch (error) {
    appendDebugLog('Failed to read live log chunk', { error: String(error) });
  } finally {
    liveChunkInFlight = false;
  }
}

function drainMonitorChunk(raw: string) {
  const combined = `${monitorController.pendingFragment}${raw}`;
  const parts = combined.split(/\r?\n/);
  if (!combined.endsWith('\n')) {
    monitorController.pendingFragment = parts.pop() ?? '';
  } else {
    monitorController.pendingFragment = '';
  }
  return parts.join('\n');
}

function startMonitorHeartbeat() {
  stopMonitorHeartbeat();
  if (!monitorSession.value?.sessionId) {
    return;
  }
  void sendMonitorHeartbeat();
  const interval = Math.max(5000, monitorHeartbeatInterval.value);
  monitorController.heartbeatTimerId = window.setInterval(() => {
    void sendMonitorHeartbeat();
  }, interval);
}

function stopMonitorHeartbeat() {
  if (monitorController.heartbeatTimerId) {
    window.clearInterval(monitorController.heartbeatTimerId);
    monitorController.heartbeatTimerId = null;
  }
}

async function sendMonitorHeartbeat() {
  if (!monitorSession.value?.sessionId) {
    return;
  }
  try {
    const session = await api.heartbeatRaidLogMonitor(raidId, monitorSession.value.sessionId);
    if (session) {
      monitorSession.value = session;
    }
  } catch (error) {
    const status =
      typeof error === 'object' && error && 'response' in error
        ? (error as { response?: { status?: number } }).response?.status
        : undefined;
    appendDebugLog('Log monitor heartbeat failed', {
      error: String(error),
      status
    });
    if (status === 404) {
      cleanupMonitorController();
      monitorSession.value = null;
      await fetchMonitorStatus();
    }
  }
}

function cleanupMonitorController() {
  stopLiveLogPolling();
  stopMonitorHeartbeat();
  monitorController.fileHandle = null;
  monitorController.lastSize = 0;
  monitorController.pendingFragment = '';
  monitorController.fileSignature = null;
}

async function stopActiveMonitor(options?: { force?: boolean }) {
  if (!monitorSession.value) {
    return;
  }
  monitorStopping.value = true;
  try {
    await api.stopRaidLogMonitor(raidId, {
      sessionId: options?.force ? undefined : monitorSession.value.sessionId,
      force: options?.force
    });
  } catch (error) {
    appendDebugLog('Failed to stop log monitor', { error: String(error) });
  } finally {
    monitorStopping.value = false;
    monitorSession.value = null;
    clearingLoot.value = false;
    pendingFileHandle.value = null;
    pendingUploadFile.value = null;
    cleanupMonitorController();
    await fetchMonitorStatus();
  }
}

function sendMonitorStopBeacon(sessionId: string) {
  try {
    if (typeof navigator === 'undefined' || !navigator.sendBeacon) {
      return;
    }
    const payload = new Blob([JSON.stringify({ sessionId })], { type: 'application/json' });
    navigator.sendBeacon(`/api/raids/${raidId}/log-monitor/stop`, payload);
  } catch (error) {
    appendDebugLog('Failed to send monitor stop beacon', { error: String(error) });
  }
}

function handleBeforeUnload(event: BeforeUnloadEvent) {
  if (!monitorSession.value?.isOwner) {
    return;
  }

  if (allowImmediateUnload.value) {
    if (monitorSession.value.sessionId) {
      sendMonitorStopBeacon(monitorSession.value.sessionId);
    }
    return;
  }

  if (!pendingNavigation.value) {
    pendingNavigation.value = { type: 'refresh' };
    showLeaveMonitorModal.value = true;
  }

  event.preventDefault();
}

function handleRefreshShortcut(event: KeyboardEvent) {
  if (!monitorSession.value?.isOwner) {
    return;
  }
  const isRefreshKey =
    event.key === 'F5' || ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === 'r');
  if (!isRefreshKey) {
    return;
  }
  event.preventDefault();
  if (pendingNavigation.value) {
    return;
  }
  pendingNavigation.value = { type: 'refresh' };
  showLeaveMonitorModal.value = true;
}

function handleBeforeRouteLeave(to: any, from: any, next: (value?: boolean | string) => void) {
  if (!monitorSession.value?.isOwner) {
    next();
    return;
  }

  if (pendingNavigation.value) {
    next(false);
    return;
  }

  pendingNavigation.value = { type: 'route', to };
  showLeaveMonitorModal.value = true;
  next(false);
}

function dismissLeaveMonitorModal(shouldNavigate: boolean) {
  showLeaveMonitorModal.value = false;
  const pending = pendingNavigation.value;
  pendingNavigation.value = null;
  if (shouldNavigate) {
    void stopActiveMonitor().finally(() => {
      if (!pending) {
        return;
      }
      if (pending.type === 'route' && pending.to) {
        router.push(pending.to);
      } else if (pending.type === 'refresh') {
        allowImmediateUnload.value = true;
        window.location.reload();
      }
    });
  } else {
    allowImmediateUnload.value = false;
  }
}

function readLogFile(
  file: File,
  options?: { append?: boolean; resetKeys?: boolean; signature?: string | null }
) {
  if (!raid.value) {
    appendDebugLog('Cannot parse log before raid data loads', { file: file.name });
    return Promise.resolve();
  }

  parsing.value = true;
  parseProgress.value = 0;
  const appendMode = options?.append ?? false;
  const resetKeys = options?.resetKeys ?? !appendMode;
  const signature = options?.signature ?? buildLogSignature(file.name);
  const mode = appendMode ? 'append' : 'replace';
  appendDebugLog('Parsing started', {
    file: file.name,
    mode,
    windowStart: parsingWindowStart.value,
    windowEnd: parsingWindowEnd.value
  });

  return new Promise<void>((resolve) => {
    const reader = new FileReader();

    reader.onprogress = (progressEvent) => {
      if (progressEvent.lengthComputable) {
        parseProgress.value = Math.round((progressEvent.loaded / progressEvent.total) * 100);
      }
    };

    reader.onload = () => {
      parseProgress.value = 100;
      const content = reader.result as string;
      const startIso = parsingWindow.start ?? raid.value?.startTime ?? new Date().toISOString();
      const endIso = parsingWindow.end ?? raid.value?.endedAt ?? null;
      const start = new Date(startIso);
      const end = endIso ? new Date(endIso) : undefined;

      activateProcessedLogSignature(signature, resetKeys);

      if (!appendMode) {
        const windowStats = computeLogWindowStats(content, start, end);
        appendDebugLog('Log window stats', windowStats);
      }

      processLogContent(content, {
        append: appendMode,
        resetKeys,
        start,
        end
      });
      persistActiveProcessedLogState();
      parsing.value = false;
      resolve();
    };

    reader.onerror = () => {
      parsing.value = false;
      appendDebugLog('Failed to read log file', { error: reader.error?.message });
      resolve();
    };

    reader.readAsText(file);
  });
}

function setAllKept(value: boolean) {
  parsedLoot.value = parsedLoot.value.map((row) => ({
    ...row,
    disposition: value ? 'KEEP' : 'DISCARD'
  }));
  parsedLootPage.value = 1;
}

function getRowsByDisposition(dispositions: DetectedLootDisposition[]) {
  const allowed = new Set(dispositions);
  return parsedLoot.value.filter(
    (row) => allowed.has(row.disposition) && row.itemName && row.looterName
  );
}

function handleDispositionChange(targetRow: ParsedRow, disposition: DetectedLootDisposition) {
  if ((disposition === 'WHITELIST' || disposition === 'BLACKLIST') && !canManageLootLists.value) {
    return;
  }

  if (targetRow.disposition === disposition) {
    return;
  }

  const targetNormalized = normalizeLootItemName(targetRow.itemName);
  const targetItemId = targetRow.itemId ?? null;

  for (const row of parsedLoot.value) {
    if (rowsReferToSameItem(targetItemId, targetNormalized, row)) {
      row.disposition = disposition;
    }
  }
}

function handleDetectedModalKeydown(event: KeyboardEvent) {
  if (!detectedLootModalOpen.value || parsedLootTotalPages.value <= 1) {
    return;
  }

  if (event.key === 'ArrowRight') {
    event.preventDefault();
    if (parsedLootPage.value < parsedLootTotalPages.value) {
      parsedLootPage.value += 1;
    }
  } else if (event.key === 'ArrowLeft') {
    event.preventDefault();
    if (parsedLootPage.value > 1) {
      parsedLootPage.value -= 1;
    }
  }
}

async function saveParsedLoot() {
  if (!raid.value || parsedLoot.value.length === 0) {
    appendDebugLog('Save skipped: no detected loot present');
    return;
  }
  savingLoot.value = true;
  const rowsToKeep = getRowsByDisposition(['KEEP', 'WHITELIST']);
  const rowsToWhitelist = getRowsByDisposition(['WHITELIST']);
  const rowsToBlacklist = getRowsByDisposition(['BLACKLIST']);
  try {
    if (rowsToKeep.length > 0) {
      await api.createRaidLoot(
        raidId,
        rowsToKeep.map((row) => ({
          itemName: row.itemName,
          looterName: row.looterName,
          eventTime: row.timestamp ? row.timestamp.toISOString() : undefined,
          emoji: row.emoji
        }))
      );
      lootEvents.value = await api.fetchRaidLoot(raidId);
      appendDebugLog('Kept loot saved', { count: rowsToKeep.length });
    } else {
      appendDebugLog('All detected loot discarded for this batch');
    }

    let listsUpdated = false;
    if (rowsToWhitelist.length > 0 && canManageLootLists.value) {
      const created = await persistLootListEntries('WHITELIST', rowsToWhitelist);
      if (created > 0) {
        listsUpdated = true;
        appendDebugLog('Items added to whitelist', { count: created });
      }
    } else if (rowsToWhitelist.length > 0 && !canManageLootLists.value) {
      appendDebugLog('Whitelist updates skipped: insufficient permissions');
    }
    if (rowsToBlacklist.length > 0 && canManageLootLists.value) {
      const created = await persistLootListEntries('BLACKLIST', rowsToBlacklist);
      if (created > 0) {
        listsUpdated = true;
        appendDebugLog('Items added to blacklist', { count: created });
      }
    } else if (rowsToBlacklist.length > 0 && !canManageLootLists.value) {
      appendDebugLog('Blacklist updates skipped: insufficient permissions');
    }

    parsedLoot.value = [];
    parsedLootPage.value = 1;
    showDetectedModal.value = false;

    if (listsUpdated) {
      await refreshLootListSummary();
    }

    for (const row of rowsToKeep) {
      window.dispatchEvent(
        new CustomEvent('loot-assigned', {
          detail: {
            raidId,
            itemName: row.itemName,
            looterName: row.looterName
          }
        })
      );
    }
  } catch (error) {
    appendDebugLog('Failed to process detected loot', { error: String(error) });
    window.alert('Unable to save detected loot. Please try again.');
  } finally {
    savingLoot.value = false;
  }
}

async function persistLootListEntries(
  type: 'WHITELIST' | 'BLACKLIST',
  rows: ParsedRow[]
): Promise<number> {
  if (!raid.value || rows.length === 0) {
    return 0;
  }

  if (!canManageLootLists.value) {
    return 0;
  }

  const guildId = raid.value.guild.id;
  const seen = new Set<string>();
  let created = 0;

  for (const row of rows) {
    const normalizedName = normalizeLootItemName(row.itemName);
    const key = row.itemId != null ? `id:${row.itemId}` : `name:${normalizedName}`;
    if (seen.has(key)) {
      continue;
    }
    seen.add(key);

    if (hasExistingLootListEntry(type, row.itemId, normalizedName)) {
      continue;
    }

    try {
      await api.createGuildLootListEntry(guildId, {
        type,
        itemName: row.itemName,
        itemId: row.itemId ?? null
      });
      created += 1;
    } catch (error) {
      appendDebugLog('Failed to persist loot list entry', {
        type,
        item: row.itemName,
        error: String(error)
      });
    }
  }

  return created;
}

function hasExistingLootListEntry(
  type: 'WHITELIST' | 'BLACKLIST',
  itemId: number | null,
  normalizedName: string
) {
  const lookup = type === 'WHITELIST' ? whitelistLookup.value : blacklistLookup.value;
  return Boolean(matchesLootListEntry(lookup, itemId, normalizedName));
}

function rowsReferToSameItem(
  targetItemId: number | null,
  targetNormalizedName: string,
  row: ParsedRow
) {
  if (targetItemId != null && row.itemId != null) {
    return row.itemId === targetItemId;
  }
  return normalizeLootItemName(row.itemName) === targetNormalizedName;
}

function normalizeMethodName(value?: string | null) {
  return value?.trim().toLowerCase() ?? '';
}

function sanitizeIgnoredMethods(methods: string[]) {
  const seen = new Set<string>();
  const sanitized: string[] = [];
  for (const method of methods) {
    const trimmed = method?.trim();
    if (!trimmed) {
      continue;
    }
    const normalized = normalizeMethodName(trimmed);
    if (!normalized || seen.has(normalized)) {
      continue;
    }
    seen.add(normalized);
    sanitized.push(trimmed);
  }
  return sanitized;
}

async function addItemToLootList(type: 'WHITELIST' | 'BLACKLIST') {
  if (!raid.value || !canManageLootLists.value) {
    closeLootContextMenu();
    return;
  }

  try {
    const entry = await api.createGuildLootListEntry(raid.value.guild.id, {
      type,
      itemName: lootContextMenu.itemName,
      itemId: lootContextMenu.itemId
    });
    appendDebugLog(`Item added to ${type.toLowerCase()}`, { itemName: lootContextMenu.itemName });
    applyLootListEntryUpsert(type, entry);
    if (type === 'WHITELIST') {
      lootContextMenu.whitelistEntry = entry;
    } else {
      lootContextMenu.blacklistEntry = entry;
    }
    await refreshLootListSummary();
  } catch (error) {
    appendDebugLog(`Failed to add item to ${type.toLowerCase()}`, {
      itemName: lootContextMenu.itemName,
      error: String(error)
    });
    window.alert('Unable to update loot list.');
  } finally {
    closeLootContextMenu();
  }
}

async function removeItemFromLootList(type: 'WHITELIST' | 'BLACKLIST') {
  if (!raid.value || !canManageLootLists.value) {
    closeLootContextMenu();
    return;
  }

  const entry =
    type === 'WHITELIST' ? lootContextMenu.whitelistEntry : lootContextMenu.blacklistEntry;

  if (!entry) {
    closeLootContextMenu();
    return;
  }

  try {
    await api.deleteGuildLootListEntry(raid.value.guild.id, entry.id);
    appendDebugLog(`Item removed from ${type.toLowerCase()}`, {
      itemName: lootContextMenu.itemName
    });
    applyLootListEntryRemoval(type, entry.id);
    await refreshLootListSummary();
  } catch (error) {
    appendDebugLog(`Failed to remove item from ${type.toLowerCase()}`, {
      itemName: lootContextMenu.itemName,
      error: String(error)
    });
    window.alert('Unable to update loot list.');
  } finally {
    closeLootContextMenu();
  }
}

function ensureLootListSummary() {
  if (!lootListSummary.value) {
    lootListSummary.value = { whitelist: [], blacklist: [] };
  }
}

function applyLootListEntryUpsert(type: 'WHITELIST' | 'BLACKLIST', entry: GuildLootListEntry) {
  ensureLootListSummary();
  const target =
    type === 'WHITELIST' ? lootListSummary.value!.whitelist : lootListSummary.value!.blacklist;
  const normalized = normalizeLootItemName(entry.itemName);
  const existingIndex = target.findIndex((item) => {
    if (item.id === entry.id) {
      return true;
    }
    if (entry.itemId != null && item.itemId != null) {
      return item.itemId === entry.itemId;
    }
    return item.itemNameNormalized === normalized;
  });
  const prepared: GuildLootListEntry = {
    ...entry,
    itemNameNormalized: entry.itemNameNormalized?.length ? entry.itemNameNormalized : normalized
  };
  if (existingIndex >= 0) {
    target.splice(existingIndex, 1, prepared);
  } else {
    target.push(prepared);
  }
}

function applyLootListEntryRemoval(type: 'WHITELIST' | 'BLACKLIST', entryId: string) {
  ensureLootListSummary();
  const target =
    type === 'WHITELIST' ? lootListSummary.value!.whitelist : lootListSummary.value!.blacklist;
  const index = target.findIndex((item) => item.id === entryId);
  if (index >= 0) {
    target.splice(index, 1);
  }
  if (type === 'WHITELIST') {
    lootContextMenu.whitelistEntry = null;
  } else {
    lootContextMenu.blacklistEntry = null;
  }
}

async function persistAutoKeptLoot(entries: ParsedLootEvent[], emoji: string) {
  if (!raid.value || entries.length === 0 || !canManageLoot.value) {
    return;
  }

  const payload = entries
    .map((entry) => {
      const itemName = entry.itemName ?? entry.looter ?? 'Unknown Item';
      const looterName = entry.looter ?? entry.itemName ?? 'Unknown';
      if (!itemName || !looterName) {
        return null;
      }
      return {
        itemName,
        looterName,
        eventTime: entry.timestamp ? entry.timestamp.toISOString() : undefined,
        emoji
      };
    })
    .filter((entry): entry is NonNullable<typeof entry> => Boolean(entry));

  if (payload.length === 0) {
    return;
  }

  try {
    await api.createRaidLoot(raidId, payload);
    lootEvents.value = await api.fetchRaidLoot(raidId);
    for (const entry of payload) {
      window.dispatchEvent(
        new CustomEvent('loot-assigned', {
          detail: {
            raidId,
            itemName: entry.itemName,
            looterName: entry.looterName
          }
        })
      );
    }
  } catch (error) {
    appendDebugLog('Failed to auto-add whitelisted loot', { error: String(error) });
  }
}

async function createManualEntry() {
  if (!manualForm.itemName || !manualForm.looterName) {
    appendDebugLog('Manual entry blocked: missing item or looter');
    return;
  }
  manualSaving.value = true;
  try {
    await api.createRaidLoot(raidId, [manualForm]);
    lootEvents.value = await api.fetchRaidLoot(raidId);
    resetManualForm();
    showManualModal.value = false;
    appendDebugLog('Manual loot entry created');
    window.dispatchEvent(
      new CustomEvent('loot-assigned', {
        detail: {
          raidId,
          itemName: manualForm.itemName,
          looterName: manualForm.looterName
        }
      })
    );
  } finally {
    manualSaving.value = false;
  }
}

async function confirmDelete(event: RaidLootEvent) {
  if (!confirm('Remove this loot entry?')) {
    return;
  }
  await api.deleteRaidLoot(raidId, event.id);
  lootEvents.value = lootEvents.value.filter((loot) => loot.id !== event.id);
}

function openEdit(event: RaidLootEvent) {
  const itemName = prompt('Item name', event.itemName);
  if (!itemName) {
    return;
  }
  const looterName = prompt('Looter', event.looterName) ?? event.looterName;
  const emoji =
    prompt('Emoji', event.emoji ?? parserSettings.value?.emoji ?? 'üíé') ?? event.emoji ?? undefined;
  api
    .updateRaidLoot(raidId, event.id, {
      itemName,
      looterName,
      emoji
    })
    .then(async () => {
      lootEvents.value = await api.fetchRaidLoot(raidId);
    });
}

async function saveParserSettings() {
  updatingSettings.value = true;
  try {
    const payload = {
      emoji: editableSettings.emoji,
      patterns: editableSettings.patterns.map((pattern, index) => ({
        id: pattern.id || `pattern-${index}`,
        label: pattern.label || `Pattern ${index + 1}`,
        pattern: convertPlaceholdersToRegex(pattern.pattern),
        ignoredMethods: sanitizeIgnoredMethods(pattern.ignoredMethods ?? [])
      }))
    };
    const settings = await api.updateGuildLootSettings(raid.value!.guild.id, payload);
    syncEditableParserSettings(settings);
    showSettings.value = false;
  } finally {
    updatingSettings.value = false;
  }
}

function addPattern(initialPattern?: string) {
  editableSettings.patterns.push({
    id: `pattern-${Date.now()}`,
    label: 'New Pattern',
    pattern: typeof initialPattern === 'string' ? initialPattern : defaultPattern(),
    ignoredMethods: [],
    methodInput: ''
  });
  activePatternIndex.value = editableSettings.patterns.length - 1;
  const newId = editableSettings.patterns[activePatternIndex.value].id;
  collapsedPatternIds.value = {
    ...collapsedPatternIds.value,
    [newId]: false
  };
  const initialLength = editableSettings.patterns[activePatternIndex.value].pattern?.length ?? 0;
  patternCaretPositions.value[newId] = { start: initialLength, end: initialLength };
}

function removePattern(index: number) {
  const removed = editableSettings.patterns.splice(index, 1)[0];
  if (activePatternIndex.value === index) {
    activePatternIndex.value = editableSettings.patterns.length ? Math.max(0, index - 1) : null;
  }
  if (removed) {
    const { [removed.id]: _, ...rest } = collapsedPatternIds.value;
    collapsedPatternIds.value = rest;
    const { [removed.id]: __, ...caretRest } = patternCaretPositions.value;
    patternCaretPositions.value = caretRest;
    const { [removed.id]: ___, ...textareaRest } = patternTextareas.value;
    patternTextareas.value = textareaRest;
  }
}

function syncEditableParserSettings(settings: GuildLootParserSettings) {
  const preparedPatterns = preparePatternsForParsing(settings.patterns);
  parserSettings.value = {
    ...settings,
    patterns: preparedPatterns
  };
  const editablePatterns: EditablePattern[] = preparedPatterns.map((pattern) => {
    const friendlyPattern = convertRegexToPlaceholders(pattern.pattern);
    const rawIgnored = Array.isArray(pattern.ignoredMethods)
      ? pattern.ignoredMethods.map((method) => method.toString())
      : [];
    return {
      ...pattern,
      pattern: friendlyPattern || pattern.pattern,
      ignoredMethods: sanitizeIgnoredMethods(rawIgnored),
      methodInput: ''
    };
  });
  editableSettings.patterns = editablePatterns;
  editableSettings.emoji = settings.emoji;
  manualForm.emoji = settings.emoji;
  activePatternIndex.value = editablePatterns.length ? 0 : null;
  collapsedPatternIds.value = editablePatterns.reduce<Record<string, boolean>>((acc, pattern) => {
    acc[pattern.id] = false;
    return acc;
  }, {});
  patternCaretPositions.value = editablePatterns.reduce<
    Record<string, { start: number; end: number }>
  >((acc, pattern) => {
    const length = pattern.pattern?.length ?? 0;
    acc[pattern.id] = { start: length, end: length };
    return acc;
  }, {});
}

function defaultPattern() {
  return '{timestamp} {item} has been awarded to {looter} by the {method}.';
}

function setActivePattern(index: number) {
  activePatternIndex.value = index;
}

function appendPlaceholder(token: string) {
  if (!editableSettings.patterns.length) {
    addPattern('');
  }
  const index = activePatternIndex.value ?? editableSettings.patterns.length - 1;
  const target = editableSettings.patterns[index];
  const patternId = target.id;
  const current = target.pattern ?? '';
  const caret = patternCaretPositions.value[patternId];
  const start = caret?.start ?? current.length;
  const end = caret?.end ?? start;
  const before = current.slice(0, start);
  const after = current.slice(end);
  const updated = `${before}${token}${after}`;
  target.pattern = updated;
  const nextPos = start + token.length;
  patternCaretPositions.value[patternId] = { start: nextPos, end: nextPos };
  nextTick(() => {
    const textarea = patternTextareas.value[patternId];
    if (textarea) {
      textarea.focus();
      textarea.setSelectionRange(nextPos, nextPos);
    }
  });
}

function placeholderUsage(pattern: string) {
  const lower = pattern?.toLowerCase() ?? '';
  return placeholderOptions.filter((option) => lower.includes(option.token.toLowerCase()));
}

function patternIncludesMethod(pattern: string) {
  return placeholderUsage(pattern).some((option) => option.token === '{method}');
}

function addIgnoredMethod(patternIndex: number) {
  const pattern = editableSettings.patterns[patternIndex];
  if (!pattern) {
    return;
  }
  const rawValue = pattern.methodInput?.trim();
  if (!rawValue) {
    return;
  }
  const normalized = normalizeMethodName(rawValue);
  if (!normalized) {
    pattern.methodInput = '';
    return;
  }
  const duplicate = pattern.ignoredMethods.some(
    (method) => normalizeMethodName(method) === normalized
  );
  if (!duplicate) {
    pattern.ignoredMethods = [...pattern.ignoredMethods, rawValue];
  }
  pattern.methodInput = '';
}

function removeIgnoredMethod(patternIndex: number, method: string) {
  const pattern = editableSettings.patterns[patternIndex];
  if (!pattern) {
    return;
  }
  pattern.ignoredMethods = pattern.ignoredMethods.filter((value) => value !== method);
}

function patternPreview(phrase: string) {
  const preview = convertPlaceholdersToRegex(phrase);
  return preview || 'Waiting for placeholders‚Ä¶';
}

function patternSampleResult(pattern: EditablePattern): PatternSampleResult {
  const sample = sampleLogLine.value.trim();
  if (!sample) {
    return { matches: false, reason: 'Enter a sample log line above.' };
  }

  const compiled = convertPlaceholdersToRegex(pattern.pattern);
  if (!compiled.trim()) {
    return { matches: false, reason: 'Add placeholders to build a valid phrase.' };
  }

  try {
    const regex = new RegExp(compiled, 'i');
    const match = sample.match(regex);
    if (!match) {
      return { matches: false, reason: 'No match for sample.' };
    }

    const looter = match.groups?.looter ?? match[1];
    const item = match.groups?.item ?? match[2];
    const methodRaw = match.groups?.method ?? match[3];
    const displayMethod = methodRaw
      ? methodRaw.trim().replace(/^./, (char) => char.toUpperCase())
      : undefined;
    const normalizedMethod = normalizeMethodName(methodRaw);

    if (
      normalizedMethod &&
      Array.isArray(pattern.ignoredMethods) &&
      pattern.ignoredMethods.some((ignored) => normalizeMethodName(ignored) === normalizedMethod)
    ) {
      return {
        matches: false,
        ignored: true,
        reason: 'Matches sample line, but the loot method is currently ignored.'
      };
    }

    return {
      matches: true,
      looter: looter?.trim(),
      item: item?.trim(),
      method: displayMethod
    };
  } catch (err) {
    return {
      matches: false,
      reason: 'Invalid pattern. Check your placeholders.',
      error: err instanceof Error ? err.message : String(err)
    };
  }
}

function togglePatternCollapse(id: string) {
  collapsedPatternIds.value = {
    ...collapsedPatternIds.value,
    [id]: !collapsedPatternIds.value[id]
  };
}

function setPatternTextareaRef(id: string, el: HTMLTextAreaElement | null) {
  if (el) {
    patternTextareas.value[id] = el;
  } else {
    const { [id]: _, ...rest } = patternTextareas.value;
    patternTextareas.value = rest;
  }
}

function updateCaretPosition(id: string) {
  const textarea = patternTextareas.value[id];
  if (!textarea) {
    return;
  }
  patternCaretPositions.value[id] = {
    start: textarea.selectionStart ?? textarea.value.length,
    end: textarea.selectionEnd ?? textarea.selectionStart ?? textarea.value.length
  };
}

function handleTextareaFocus(index: number, id: string) {
  setActivePattern(index);
  updateCaretPosition(id);
}

function openManualModal() {
  showManualModal.value = true;
}

function closeManualModal() {
  showManualModal.value = false;
  resetManualForm();
}

function resetManualForm() {
  manualForm.itemName = '';
  manualForm.looterName = '';
  manualForm.looterClass = '';
  manualForm.emoji = parserSettings.value?.emoji ?? 'üíé';
  manualForm.note = '';
}

function initializeParsingWindow() {
  parsingWindow.start = raid.value?.startTime ?? null;
  parsingWindow.end = raid.value?.endedAt ?? null;
}

function openWindowModal() {
  parsingWindowForm.start = toInputValue(parsingWindow.start ?? raid.value?.startTime ?? null);
  parsingWindowForm.end = toInputValue(parsingWindow.end ?? raid.value?.endedAt ?? null);
  showWindowModal.value = true;
}

function closeWindowModal() {
  showWindowModal.value = false;
}

function saveParsingWindow() {
  const startIso = fromInputValue(parsingWindowForm.start) ?? raid.value?.startTime ?? null;
  const endIso = fromInputValue(parsingWindowForm.end);
  parsingWindow.start = startIso;
  parsingWindow.end = endIso;
  showWindowModal.value = false;
  appendDebugLog('Parsing window updated', {
    startUtc: startIso,
    startLocal: startIso ? formatDate(startIso) : null,
    endUtc: endIso,
    endLocal: endIso ? formatDate(endIso) : 'Current log end'
  });
}

function resetWindowToRaidTimes() {
  initializeParsingWindow();
  parsingWindowForm.start = toInputValue(parsingWindow.start);
  parsingWindowForm.end = toInputValue(parsingWindow.end);
  appendDebugLog('Parsing window reset to raid times', {
    startUtc: parsingWindow.start,
    startLocal: parsingWindow.start ? formatDate(parsingWindow.start) : null,
    endUtc: parsingWindow.end,
    endLocal: parsingWindow.end ? formatDate(parsingWindow.end) : 'Current log end'
  });
}

function resolveWindowBounds() {
  const startIso = parsingWindow.start ?? raid.value?.startTime ?? null;
  const endIso = parsingWindow.end ?? raid.value?.endedAt ?? null;
  if (startIso && endIso) {
    const startDate = new Date(startIso).getTime();
    const endDate = new Date(endIso).getTime();
    if (startDate <= endDate) {
      return { earlier: startIso, later: endIso };
    }
    return { earlier: endIso, later: startIso };
  }
  return { earlier: startIso, later: endIso };
}

function toInputValue(value: string | null) {
  if (!value) {
    return '';
  }
  const date = new Date(value);
  const offset = date.getTimezoneOffset();
  const localDate = new Date(date.getTime() - offset * 60 * 1000);
  return localDate.toISOString().slice(0, 16);
}

function fromInputValue(value: string) {
  if (!value) {
    return null;
  }
  const parsed = new Date(value);
  if (Number.isNaN(parsed.getTime())) {
    return null;
  }
  return parsed.toISOString();
}

function enqueueLootConsoleEntries(entries: LootConsolePayload[]) {
  if (!monitorSession.value || entries.length === 0) {
    return;
  }

  const normalized = entries
    .map((entry) => ({
      line: entry.line?.trim() ?? '',
      status: entry.status
    }))
    .filter((entry) => entry.line.length > 0);

  if (normalized.length === 0) {
    return;
  }

  const timestamp = Date.now();
  for (const [index, entry] of normalized.entries()) {
    lootConsoleQueue.value.push({
      id: `console-${timestamp}-${index}-${Math.random().toString(36).slice(2, 6)}`,
      line: entry.line,
      status: entry.status
    });
  }

  if (!lootConsoleCurrent.value) {
    showNextLootConsoleEntry();
  }
}

function showNextLootConsoleEntry() {
  if (lootConsoleCurrent.value || lootConsoleQueue.value.length === 0) {
    return;
  }

  const next = lootConsoleQueue.value.shift() ?? null;
  if (!next) {
    return;
  }

  lootConsoleCurrent.value = next;

  if (lootConsoleTimerId.value) {
    window.clearTimeout(lootConsoleTimerId.value);
    lootConsoleTimerId.value = null;
  }

  lootConsoleTimerId.value = window.setTimeout(() => {
    lootConsoleTimerId.value = null;
    lootConsoleCurrent.value = null;

    if (lootConsoleCooldownId.value) {
      window.clearTimeout(lootConsoleCooldownId.value);
      lootConsoleCooldownId.value = null;
    }

    lootConsoleCooldownId.value = window.setTimeout(() => {
      lootConsoleCooldownId.value = null;
      showNextLootConsoleEntry();
    }, 200);
  }, 1500);
}

function clearLootConsole() {
  lootConsoleQueue.value = [];
  lootConsoleCurrent.value = null;
  if (lootConsoleTimerId.value) {
    window.clearTimeout(lootConsoleTimerId.value);
    lootConsoleTimerId.value = null;
  }
  if (lootConsoleCooldownId.value) {
    window.clearTimeout(lootConsoleCooldownId.value);
    lootConsoleCooldownId.value = null;
  }
}

function handleLootConsoleSuppress() {
  clearLootConsole();
}

function processLogContent(
  content: string,
  options: { append: boolean; resetKeys?: boolean; start: Date; end?: Date }
) {
  if (!raid.value) {
    return;
  }

  if (options.resetKeys) {
    processedLogKeys.clear();
    parsedLootPage.value = 1;
  }

  const patterns = getPatternsForParsing();
  const emoji = parserSettings.value?.emoji ?? 'üíé';
  const parsed = parseLootLog(content, options.start, options.end, patterns);
  const includeConsole = Boolean(monitorSession.value);
  const consolePayloads: LootConsolePayload[] = [];

  if (parsed.length === 0) {
    if (!options.append) {
      parsedLoot.value = [];
      parsedLootPage.value = 1;
    }
    appendDebugLog('Parsing completed', {
      parsedCount: 0,
      appended: options.append
    });
    return;
  }

  const manualEntries: ParsedLootEvent[] = [];
  const autoKept: ParsedLootEvent[] = [];
  const autoDiscarded: ParsedLootEvent[] = [];
  const patternLookup = new Map<string, GuildLootParserPattern>();
  for (const pattern of patterns) {
    patternLookup.set(pattern.id, pattern);
  }

  for (const entry of parsed) {
    const key = buildParsedEventKey(entry);
    if (processedLogKeys.has(key)) {
      if (includeConsole) {
        consolePayloads.push({
          line: formatConsoleLine(entry),
          status: 'REJECTED'
        });
      }
      continue;
    }

    const matchedPattern = entry.patternId ? patternLookup.get(entry.patternId) : undefined;
    if (shouldIgnoreByMethod(matchedPattern, entry.method)) {
      processedLogKeys.add(key);
      appendDebugLog('Ignored loot due to method filter', {
        method: entry.method ?? null,
        patternId: entry.patternId
      });
      if (includeConsole) {
        consolePayloads.push({
          line: formatConsoleLine(entry),
          status: 'REJECTED'
        });
      }
      continue;
    }

    const candidateName = entry.itemName ?? entry.looter ?? null;
    const normalizedName = candidateName ? normalizeLootItemName(candidateName) : null;
    const itemId = entry.itemId ?? null;

    const whitelistMatch = matchesLootListEntry(whitelistLookup.value, itemId, normalizedName);
    if (whitelistMatch) {
      processedLogKeys.add(key);
      autoKept.push({
        ...entry,
        itemName: candidateName ?? 'Unknown Item',
        looter: entry.looter ?? entry.itemName ?? 'Unknown'
      });
      if (includeConsole) {
        consolePayloads.push({
          line: formatConsoleLine(entry),
          status: 'ACCEPTED'
        });
      }
      continue;
    }

    const blacklistMatch = matchesLootListEntry(blacklistLookup.value, itemId, normalizedName);
    if (blacklistMatch) {
      processedLogKeys.add(key);
      autoDiscarded.push(entry);
      if (includeConsole) {
        consolePayloads.push({
          line: formatConsoleLine(entry),
          status: 'REJECTED'
        });
      }
      continue;
    }

    manualEntries.push(entry);
  }

  if (autoKept.length > 0) {
    void persistAutoKeptLoot(autoKept, emoji);
    appendDebugLog('Automatically kept whitelisted loot', { count: autoKept.length });
  }

  if (autoDiscarded.length > 0) {
    appendDebugLog('Automatically discarded blacklisted loot', { count: autoDiscarded.length });
  }

  const newRows = transformParsedEvents(manualEntries, emoji, (entry, result) => {
    if (includeConsole) {
      consolePayloads.push({
        line: formatConsoleLine(entry),
        status: result
      });
    }
  });
  if (newRows.length === 0) {
    appendDebugLog('Parsing completed with no new loot rows', {
      parsedCount: parsed.length,
      appended: options.append,
      autoKept: autoKept.length,
      autoDiscarded: autoDiscarded.length
    });
    if (includeConsole) {
      enqueueLootConsoleEntries(consolePayloads);
    }
    return;
  }

  parsedLoot.value = options.append ? [...parsedLoot.value, ...newRows] : newRows;
  if (parsedLoot.value.length > 0) {
    showDetectedModal.value = true;
    parsedLootPage.value = 1;
    if (monitorSession.value?.isOwner) {
      void playDetectedChime();
    }
  }
  appendDebugLog('Parsing completed', {
    parsedCount: parsed.length,
    appended: options.append,
    addedRows: newRows.length,
    autoKept: autoKept.length,
    autoDiscarded: autoDiscarded.length
  });
  if (includeConsole) {
    enqueueLootConsoleEntries(consolePayloads);
  }
}

function formatConsoleLine(entry: ParsedLootEvent) {
  if (entry.rawLine && entry.rawLine.trim().length > 0) {
    return entry.rawLine.trim();
  }
  const parts: string[] = [];
  if (entry.timestamp) {
    parts.push(entry.timestamp);
  }
  if (entry.looter) {
    parts.push(entry.looter);
  }
  if (entry.itemName) {
    parts.push(`‚Üí ${entry.itemName}`);
  }
  if (parts.length === 0) {
    return 'Loot event detected';
  }
  return parts.join(' ');
}

function transformParsedEvents(
  parsed: ParsedLootEvent[],
  emoji: string,
  onProcessed?: (entry: ParsedLootEvent, result: LootConsoleStatus) => void
): ParsedRow[] {
  const patternLookup = new Map<string, GuildLootParserPattern>();
  for (const pattern of getPatternsForParsing()) {
    patternLookup.set(pattern.id, pattern);
  }
  const rows: ParsedRow[] = [];
  for (const entry of parsed) {
    const key = buildParsedEventKey(entry);
    if (processedLogKeys.has(key)) {
      onProcessed?.(entry, 'REJECTED');
      continue;
    }
    const matchedPattern = entry.patternId ? patternLookup.get(entry.patternId) : undefined;
    if (shouldIgnoreByMethod(matchedPattern, entry.method)) {
      appendDebugLog('Ignored detected loot row due to method filter', {
        method: entry.method ?? null,
        patternId: entry.patternId
      });
      onProcessed?.(entry, 'REJECTED');
      continue;
    }
    processedLogKeys.add(key);
    const itemName = entry.itemName ?? entry.looter ?? 'Unknown Item';
    const looterName = entry.looter ?? entry.itemName ?? 'Unknown';
    rows.push({
      id: `parsed-${processedLogKeys.size}-${Math.random().toString(36).slice(2, 8)}`,
      timestamp: entry.timestamp,
      rawLine: entry.rawLine,
      itemName,
      itemId: entry.itemId ?? null,
      looterName,
      emoji,
      disposition: 'KEEP'
    });
    onProcessed?.(entry, 'ACCEPTED');
  }
  return rows;
}

function shouldIgnoreByMethod(
  pattern: GuildLootParserPattern | undefined,
  method: string | null | undefined
) {
  if (!pattern?.ignoredMethods || pattern.ignoredMethods.length === 0) {
    return false;
  }
  const methodNormalized = normalizeMethodName(method);
  if (!methodNormalized) {
    return false;
  }
  return pattern.ignoredMethods.some(
    (ignored) => normalizeMethodName(ignored) === methodNormalized
  );
}

function buildParsedEventKey(entry: ParsedLootEvent) {
  const timestamp = entry.timestamp ? entry.timestamp.toISOString() : 'unknown';
  return `${timestamp}::${entry.rawLine}`;
}

const formatLooterLabel = (name: string, looterClass?: string | null) => {
  const classLabel = formatCharacterClassLabel(looterClass);
  return classLabel ? `${name} (${classLabel})` : name;
};

function handleExistingLootCardClick(event: MouseEvent, itemName: string) {
  const target = event.target as HTMLElement | null;
  if (target?.closest('a')) {
    return;
  }
  openAllaSearch(itemName);
}

function handleExistingLootCardKeyEnter(event: KeyboardEvent, itemName: string) {
  const target = event.target as HTMLElement | null;
  if (target?.closest('a')) {
    return;
  }
  openAllaSearch(itemName);
}

const formatCharacterClassLabel = (value?: string | null) => {
  if (!value) {
    return null;
  }
  const normalized = value.trim();
  if (!normalized) {
    return null;
  }
  const upper = normalized.toUpperCase() as CharacterClass;
  if (upper in characterClassLabels) {
    return characterClassLabels[upper];
  }
  return normalized.charAt(0).toUpperCase() + normalized.slice(1).toLowerCase();
};

function computeLogWindowStats(content: string, start: Date, end?: Date) {
  const lines = content.split(/\r?\n/);
  let timestampedLines = 0;
  let withinWindowLines = 0;
  const samples: string[] = [];
  for (const line of lines) {
    const timestamp = extractConsoleTimestamp(line);
    if (!timestamp) {
      continue;
    }
    timestampedLines++;
    if (!isTimestampWithinWindow(timestamp, start, end)) {
      continue;
    }
    withinWindowLines++;
    if (samples.length < 3) {
      samples.push(line.trim());
    }
  }
  return { timestampedLines, withinWindowLines, samples };
}

function extractConsoleTimestamp(line: string) {
  const match = line.match(consoleTimestampRegex);
  if (!match?.groups) {
    return null;
  }
  const { day, month, date, time, year } = match.groups;
  const composed = `${day} ${month} ${date} ${time} ${year}`;
  const parsed = new Date(composed);
  return Number.isNaN(parsed.getTime()) ? null : parsed;
}

function isTimestampWithinWindow(timestamp: Date, start: Date, end?: Date) {
  if (timestamp < start) {
    return false;
  }
  if (end && timestamp > end) {
    return false;
  }
  return true;
}

function getPatternsForParsing() {
  if (parserSettings.value?.patterns?.length) {
    return parserSettings.value.patterns;
  }
  return defaultRegexPatterns;
}

function formatDate(date: string) {
  return new Intl.DateTimeFormat('en-US', {
    dateStyle: 'medium',
    timeStyle: 'short'
  }).format(new Date(date));
}

function formatRelativeTime(value: string) {
  try {
    const formatter = new Intl.RelativeTimeFormat('en', { numeric: 'auto' });
    const delta = new Date(value).getTime() - Date.now();
    const minutes = Math.round(delta / 60000);
    if (Math.abs(minutes) < 1) {
      return 'just now';
    }
    if (Math.abs(minutes) < 60) {
      return formatter.format(minutes, 'minute');
    }
    const hours = Math.round(minutes / 60);
    return formatter.format(hours, 'hour');
  } catch {
    return formatDate(value);
  }
}

function formatFileSize(bytes: number) {
  if (!Number.isFinite(bytes)) {
    return '0 B';
  }
  const thresholds = ['B', 'KB', 'MB', 'GB', 'TB'];
  let value = bytes;
  let unitIndex = 0;
  while (value >= 1024 && unitIndex < thresholds.length - 1) {
    value /= 1024;
    unitIndex += 1;
  }
  return `${value.toFixed(value < 10 && unitIndex > 0 ? 1 : 0)} ${thresholds[unitIndex]}`;
}

function ensureAwardingPatterns(patterns: GuildLootParserPattern[]) {
  if (!Array.isArray(patterns) || patterns.length === 0) {
    return defaultRegexPatterns;
  }
  const hasAwarding = patterns.some((pattern) =>
    pattern.pattern?.includes('has\\s+been\\s+awarded')
  );
  if (hasAwarding) {
    return patterns;
  }
  const missingDefaults = defaultRegexPatterns.filter(
    (pattern) => !patterns.some((existing) => existing.pattern === pattern.pattern)
  );
  return [...patterns, ...missingDefaults];
}

function preparePatternsForParsing(patterns: GuildLootParserPattern[]) {
  const merged = ensureAwardingPatterns(patterns);
  return merged.map((pattern) => ({
    ...pattern,
    ignoredMethods: sanitizeIgnoredMethods(pattern.ignoredMethods ?? []),
    pattern: pattern.pattern.includes('{')
      ? convertPlaceholdersToRegex(pattern.pattern)
      : pattern.pattern
  }));
}

const consoleTimestampRegex =
  /^\[(?<day>\w{3}) (?<month>\w{3}) (?<date>\d{1,2}) (?<time>\d{2}:\d{2}:\d{2}) (?<year>\d{4})]/;

function appendDebugLog(message: string, context?: Record<string, unknown>) {
  const entry: DebugLogEntry = {
    id: Date.now() + Math.random(),
    timestamp: new Date(),
    message,
    context
  };
  debugLogs.value = [...debugLogs.value.slice(-199), entry];
}

function formatContext(context: Record<string, unknown>) {
  return JSON.stringify(context, null, 2);
}

async function copyDebugLogs() {
  if (debugLogs.value.length === 0) {
    return;
  }
  const serialized = debugLogs.value
    .map((entry) => {
      const base = `[${entry.timestamp.toISOString()}] ${entry.message}`;
      if (entry.context) {
        return `${base}\n${formatContext(entry.context)}`;
      }
      return base;
    })
    .join('\n\n');
  try {
    // @ts-expect-error: navigator may be undefined in SSR
    if (navigator?.clipboard?.writeText) {
      await navigator.clipboard.writeText(serialized);
    } else {
      const textarea = document.createElement('textarea');
      textarea.value = serialized;
      textarea.style.position = 'fixed';
      textarea.style.opacity = '0';
      document.body.appendChild(textarea);
      textarea.select();
      document.execCommand('copy');
      document.body.removeChild(textarea);
    }
    appendDebugLog('Debug console copied to clipboard');
  } catch (error) {
    appendDebugLog('Failed to copy debug logs', { error: String(error) });
  }
}

function resetDetectedLoot() {
  parsedLoot.value = [];
  if (activeLogSignature.value) {
    clearStoredProcessedKeys(activeLogSignature.value);
  }
  processedLogKeys.clear();
  activeLogSignature.value = null;
  showDetectedModal.value = false;
  appendDebugLog('Detected loot reset');
}

function closeDetectedLootModal() {
  showDetectedModal.value = false;
  parsedLootPage.value = 1;
}

function playDetectedChime() {
  if (typeof window === 'undefined' || typeof window.AudioContext === 'undefined') {
    return;
  }
  try {
    lootAudioContext = lootAudioContext ?? new window.AudioContext();
    const ctx = lootAudioContext;
    if (ctx.state === 'suspended') {
      void ctx.resume();
    }
    const oscillator = ctx.createOscillator();
    oscillator.type = 'triangle';
    oscillator.frequency.value = 880;
    const gain = ctx.createGain();
    gain.gain.value = 0.12;
    oscillator.connect(gain);
    gain.connect(ctx.destination);
    const now = ctx.currentTime;
    gain.gain.setValueAtTime(0.12, now);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.25);
    oscillator.start(now);
    oscillator.stop(now + 0.3);
  } catch (error) {
    appendDebugLog('Unable to play detected loot chime', { error: String(error) });
  }
}

async function deleteLootGroup(entry: GroupedLootEntry, options?: { skipConfirm?: boolean }) {
  if (!canDeleteExistingLoot.value) {
    return;
  }
  if (!options?.skipConfirm) {
    const confirmed = confirm(
      `Remove ${entry.count} entr${entry.count === 1 ? 'y' : 'ies'} of ${entry.itemName} looted by ${entry.looterName}?`
    );
    if (!confirmed) {
      return;
    }
  }
  try {
    await Promise.all(entry.eventIds.map((lootId) => api.deleteRaidLoot(raidId, lootId)));
    lootEvents.value = lootEvents.value.filter((event) => !entry.eventIds.includes(event.id));
    appendDebugLog('Deleted loot entries', {
      itemName: entry.itemName,
      looterName: entry.looterName,
      count: entry.count
    });
  } catch (error) {
    appendDebugLog('Failed to delete loot entries', { error: String(error) });
  }
}

function openAllaSearch(itemName: string) {
  const base =
    'https://alla.clumsysworld.com/?a=items_search&&a=items&iclass=0&irace=0&islot=0&istat1=&istat1comp=%3E%3D&istat1value=&istat2=&istat2comp=%3E%3D&istat2value=&iresists=&iresistscomp=%3E%3D&iresistsvalue=&iheroics=&iheroicscomp=%3E%3D&iheroicsvalue=&imod=&imodcomp=%3E%3D&imodvalue=&itype=-1&iaugslot=0&ieffect=&iminlevel=0&ireqlevel=0&inodrop=0&iavailability=0&iavaillevel=0&ideity=0&isearch=1';
  const url = `${base}&iname=${encodeURIComponent(itemName)}`;
  window.open(url, '_blank');
}

onMounted(() => {
  window.addEventListener('beforeunload', handleBeforeUnload);
  window.addEventListener('keydown', handleRefreshShortcut);
  window.addEventListener('click', handleGlobalPointerDown);
  window.addEventListener('contextmenu', handleGlobalPointerDown);
  window.addEventListener('keydown', handleLootContextMenuKey);
  loadData();
});

onBeforeRouteLeave(handleBeforeRouteLeave);

onBeforeUnmount(() => {
  window.removeEventListener('beforeunload', handleBeforeUnload);
  window.removeEventListener('keydown', handleRefreshShortcut);
  window.removeEventListener('click', handleGlobalPointerDown);
  window.removeEventListener('contextmenu', handleGlobalPointerDown);
  window.removeEventListener('keydown', handleLootContextMenuKey);
  window.removeEventListener('keydown', handleDetectedModalKeydown);
  stopMonitorStatusPolling();
  if (monitorSession.value?.isOwner) {
    void stopActiveMonitor();
  } else {
    cleanupMonitorController();
  }
  clearLootConsole();
});
</script>

<style scoped>
.loot-view {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}

.monitor-card {
  display: flex;
  flex-direction: row;
  gap: 1.5rem;
  border-left: 4px solid #38bdf8;
}

.monitor-card__status {
  display: flex;
  align-items: center;
  gap: 1rem;
}

.monitor-card__pulse {
  width: 48px;
  height: 48px;
  border-radius: 50%;
  background: rgba(56, 189, 248, 0.15);
  position: relative;
}

.monitor-card__pulse::after {
  content: '';
  position: absolute;
  inset: 6px;
  border-radius: 50%;
  background: #38bdf8;
  animation: monitorPulse 1.4s ease-in-out infinite;
}

@keyframes monitorPulse {
  0% {
    transform: scale(0.8);
    opacity: 1;
  }
  70% {
    transform: scale(1.1);
    opacity: 0.3;
  }
  100% {
    transform: scale(0.8);
    opacity: 1;
  }
}

.monitor-card__user {
  margin: 0;
  font-weight: 600;
}

.monitor-card__file {
  margin: 0.2rem 0;
  font-family: 'IBM Plex Mono', Consolas, monospace;
  font-size: 0.9rem;
  color: #bae6fd;
}

.monitor-card__actions {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 0.5rem;
}

.header-actions {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  flex-wrap: wrap;
}

.parsing-window {
  display: flex;
  gap: 0.85rem;
  align-items: center;
  justify-content: space-between;
  flex-wrap: wrap;
  padding: 0.85rem 1rem;
  border: 1px solid rgba(59, 130, 246, 0.4);
  border-radius: 1rem;
  background: linear-gradient(135deg, rgba(15, 23, 42, 0.9), rgba(15, 118, 214, 0.15));
  color: #e2e8f0;
  box-shadow: 0 12px 30px rgba(15, 118, 214, 0.15);
}

.loot-console-container {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.75rem;
  margin-top: 0.35rem;
  max-width: 100%;
  overflow: visible;
  padding-right: 0.75rem;
}

.loot-console-stage {
  position: relative;
  min-height: 2.8rem;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: visible;
  border-radius: 0.85rem;
  isolation: isolate;
  max-width: calc(100vw - 3rem);
}

.loot-console__suppress {
  padding: 0.45rem 0.9rem;
  border-radius: 0.75rem;
  border: 1px solid rgba(148, 163, 184, 0.35);
  background: rgba(15, 23, 42, 0.75);
  color: #f8fafc;
  font-size: 0.75rem;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  cursor: pointer;
  transition: background 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
}

.loot-console__suppress:hover {
  background: rgba(30, 41, 59, 0.85);
  border-color: rgba(59, 130, 246, 0.45);
  transform: translateY(-1px);
}

.loot-console__suppress:active {
  transform: translateY(0);
}

.loot-console {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  margin: auto;
  transform: translateY(var(--loot-console-offset, 0));
  display: inline-flex;
  align-items: center;
  justify-content: flex-start;
  max-width: min(calc(100vw - 3.5rem), 720px);
  padding: 0.6rem 1rem;
  border-radius: 0.85rem;
  border: none;
  background: rgba(15, 23, 42, 0.82);
  box-shadow: none;
  color: #e2e8f0;
  font-family: 'JetBrains Mono', 'Fira Code', 'SFMono-Regular', Menlo, monospace;
  font-size: 0.85rem;
  letter-spacing: 0.03em;
  position: relative;
  overflow: hidden;
}

.loot-console::before,
.loot-console::after {
  content: '';
  position: absolute;
  left: 0;
  right: 0;
  height: 12px;
  pointer-events: none;
  z-index: 2;
  background: linear-gradient(to bottom, rgba(15, 23, 42, 0.85), transparent);
}

.loot-console::after {
  top: auto;
  bottom: 0;
  background: linear-gradient(to top, rgba(15, 23, 42, 0.85), transparent);
}

.loot-console--accepted {
  border-color: rgba(74, 222, 128, 0.35);
  color: #c4fce0;
  box-shadow: 0 12px 26px rgba(34, 197, 94, 0.22);
}

.loot-console--rejected {
  border-color: rgba(248, 113, 113, 0.35);
  color: #fed7d7;
  box-shadow: 0 12px 26px rgba(248, 113, 113, 0.2);
}

.loot-console__line {
  text-align: left;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: min(calc(100vw - 4.5rem), 680px);
}

.loot-console-transition-enter-active,
.loot-console-transition-leave-active {
  transition: transform 0.35s ease, opacity 0.35s ease;
}

.loot-console-transition-enter-from {
  --loot-console-offset: 100%;
  opacity: 0;
}

.loot-console-transition-enter-to {
  --loot-console-offset: 0;
  opacity: 1;
}

.loot-console-transition-leave-from {
  --loot-console-offset: 0;
  opacity: 1;
}

.loot-console-transition-leave-to {
  --loot-console-offset: -110%;
  opacity: 0;
}

.parsing-window__icon {
  width: 44px;
  height: 44px;
  border-radius: 0.9rem;
  background: rgba(14, 165, 233, 0.2);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.5rem;
}

.parsing-window__details {
  flex: 1;
  min-width: 220px;
}

.parsing-window__label {
  text-transform: uppercase;
  letter-spacing: 0.05em;
  font-size: 0.75rem;
  color: #94a3b8;
  margin: 0;
}

.parsing-window__range {
  margin: 0.15rem 0 0;
  font-weight: 600;
  font-size: 1rem;
}

.parsing-window__hint {
  margin: 0.1rem 0 0;
  font-size: 0.8rem;
  color: #94a3b8;
}

.parsing-window__button {
  margin-left: auto;
}

.parsing-window__button--debug {
  margin-left: 0;
  display: inline-flex;
  align-items: center;
  gap: 0.3rem;
  min-width: auto;
}

.parsing-window__button-text {
  font-size: 0.85rem;
}

.parsing-window-spacer {
  margin-top: 1.25rem;
}

.btn--settings {
  border-color: rgba(14, 165, 233, 0.6);
  color: #bae6fd;
  background: linear-gradient(135deg, rgba(14, 165, 233, 0.2), rgba(99, 102, 241, 0.25));
}

.btn--settings:hover {
  border-color: rgba(14, 165, 233, 0.85);
  color: #e0f2fe;
  background: linear-gradient(135deg, rgba(14, 165, 233, 0.35), rgba(99, 102, 241, 0.4));
}

.upload-drop {
  border: 1px dashed rgba(148, 163, 184, 0.4);
  border-radius: 1rem;
  padding: 2rem;
  text-align: center;
  color: #94a3b8;
  transition:
    border-color 0.2s ease,
    background 0.2s ease,
    color 0.2s ease;
}

.upload-drop--active {
  border-color: rgba(59, 130, 246, 0.65);
  background: rgba(59, 130, 246, 0.08);
  color: #bae6fd;
}

.upload-drop--disabled {
  opacity: 0.6;
  pointer-events: none;
}

.error-text {
  color: #f87171;
  font-size: 0.85rem;
  margin-bottom: 0.75rem;
}

.upload-drop__prompt {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  align-items: center;
}

.upload-drop__prompt p {
  margin: 0;
}

.upload-drop__button {
  display: inline-flex;
  align-items: center;
  gap: 0.45rem;
  padding: 0.45rem 1rem;
  border-radius: 999px;
  border-color: rgba(59, 130, 246, 0.65);
  color: #e0f2fe;
  background: linear-gradient(135deg, rgba(59, 130, 246, 0.25), rgba(14, 165, 233, 0.3));
  box-shadow: 0 10px 25px rgba(59, 130, 246, 0.25);
}

.upload-drop__button:hover {
  border-color: rgba(59, 130, 246, 0.9);
  background: linear-gradient(135deg, rgba(59, 130, 246, 0.35), rgba(14, 165, 233, 0.45));
  color: #fff;
}

.progress {
  margin-top: 0.75rem;
  background: rgba(30, 41, 59, 0.6);
  border-radius: 999px;
  height: 8px;
  overflow: hidden;
}

.progress__bar {
  height: 100%;
  background: linear-gradient(135deg, rgba(14, 165, 233, 0.9), rgba(99, 102, 241, 0.8));
}

.loot-table {
  width: 100%;
  border-collapse: collapse;
}

.loot-table th,
.loot-table td {
  padding: 0.5rem;
  border-bottom: 1px solid rgba(148, 163, 184, 0.1);
}

.loot-table__row--discarded {
  opacity: 0.6;
}

.loot-table input {
  width: 100%;
  background: rgba(15, 23, 42, 0.6);
  border: 1px solid rgba(148, 163, 184, 0.2);
  border-radius: 0.4rem;
  color: #e2e8f0;
  padding: 0.4rem;
}

.disposition-buttons {
  display: inline-flex;
  gap: 0.35rem;
  flex-wrap: wrap;
}

.disposition-button {
  display: inline-flex;
  align-items: center;
  gap: 0.35rem;
  border: 1px solid rgba(148, 163, 184, 0.25);
  background: rgba(15, 23, 42, 0.65);
  border-radius: 0.6rem;
  padding: 0.3rem 0.55rem;
  color: #e2e8f0;
  font-size: 0.85rem;
  transition:
    transform 0.12s ease,
    border-color 0.15s ease,
    background 0.15s ease,
    box-shadow 0.15s ease;
}

.disposition-button:hover:not(:disabled),
.disposition-button:focus-visible:not(:disabled) {
  transform: translateY(-1px);
  border-color: rgba(96, 165, 250, 0.4);
  box-shadow: 0 8px 16px rgba(15, 23, 42, 0.3);
}

.disposition-button--selected {
  border-color: rgba(56, 189, 248, 0.55);
  background: rgba(56, 189, 248, 0.15);
  box-shadow: 0 10px 20px rgba(56, 189, 248, 0.25);
}

.disposition-button--keep.disposition-button--selected {
  border-color: rgba(34, 197, 94, 0.6);
  background: rgba(34, 197, 94, 0.2);
}

.disposition-button--discard.disposition-button--selected {
  border-color: rgba(248, 113, 113, 0.5);
  background: rgba(248, 113, 113, 0.18);
}

.disposition-button--whitelist.disposition-button--selected {
  border-color: rgba(250, 204, 21, 0.6);
  background: rgba(250, 204, 21, 0.22);
}

.disposition-button--blacklist.disposition-button--selected {
  border-color: rgba(148, 163, 184, 0.5);
  background: rgba(148, 163, 184, 0.18);
}

.disposition-button:disabled {
  opacity: 0.55;
  cursor: not-allowed;
}

.disposition-button__icon {
  font-size: 0.95rem;
}

.loot-context-menu {
  position: fixed;
  z-index: 50;
  min-width: 220px;
  background: rgba(15, 23, 42, 0.95);
  border: 1px solid rgba(148, 163, 184, 0.25);
  border-radius: 0.8rem;
  box-shadow: 0 18px 40px rgba(15, 23, 42, 0.45);
  padding: 0.5rem;
  display: flex;
  flex-direction: column;
  gap: 0.35rem;
}

.loot-context-menu__header {
  font-weight: 600;
  font-size: 0.9rem;
  color: #f8fafc;
  margin-bottom: 0.25rem;
}

.loot-context-menu__action {
  background: transparent;
  border: none;
  color: #cbd5f5;
  padding: 0.4rem 0.5rem;
  text-align: left;
  border-radius: 0.5rem;
  transition:
    background 0.15s ease,
    color 0.15s ease;
}

.loot-context-menu__action:hover,
.loot-context-menu__action:focus-visible {
  background: rgba(59, 130, 246, 0.2);
  color: #f8fafc;
}

.loot-context-menu__action--remove {
  color: #fca5a5;
}

.loot-context-menu__action--remove:hover,
.loot-context-menu__action--remove:focus-visible {
  background: rgba(248, 113, 113, 0.15);
  color: #fee2e2;
}

.loot-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
  gap: 1rem;
  margin-top: 1rem;
}

.loot-card {
  background: rgba(15, 23, 42, 0.7);
  border: 1px solid rgba(148, 163, 184, 0.2);
  border-radius: 1rem;
  padding: 1rem;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  box-shadow: 0 10px 20px rgba(15, 23, 42, 0.35);
  position: relative;
  transition:
    transform 0.15s ease,
    border-color 0.15s ease,
    box-shadow 0.15s ease;
  cursor: pointer;
}

.loot-card:hover,
.loot-card:focus-visible {
  transform: translateY(-2px);
  border-color: rgba(34, 197, 94, 0.4);
  box-shadow: 0 14px 26px rgba(15, 23, 42, 0.45);
}

.loot-card__count {
  position: absolute;
  top: 0.75rem;
  right: 0.75rem;
  background: rgba(34, 197, 94, 0.2);
  border: 1px solid rgba(34, 197, 94, 0.5);
  color: #bbf7d0;
  padding: 0.2rem 0.5rem;
  border-radius: 0.65rem;
  font-weight: 700;
  font-size: 0.85rem;
}

.loot-card__badge {
  position: absolute;
  bottom: 0.55rem;
  right: 0.75rem;
  font-size: 0.95rem;
  filter: drop-shadow(0 2px 4px rgba(15, 23, 42, 0.5));
  pointer-events: none;
  z-index: 1;
}

.loot-card__badge--whitelist {
  color: #facc15;
}

.loot-card__header {
  display: flex;
  gap: 0.75rem;
  align-items: center;
  padding-right: 2.5rem;
}

.loot-card__emoji {
  font-size: 1.5rem;
}

.loot-card__item {
  margin: 0;
  font-weight: 700;
}

.loot-card__looter {
  margin: 0;
  color: #94a3b8;
}

.loot-card__looter .character-link {
  color: #38bdf8;
}

.loot-card__looter .character-link:hover,
.loot-card__looter .character-link:focus-visible {
  color: #f8fafc;
}

.loot-card__looter-class {
  margin-left: 0.35rem;
}

.loot-card__note {
  margin: 0;
  font-size: 0.85rem;
  color: #cbd5f5;
}

.loot-card__actions {
  display: flex;
  gap: 0.5rem;
  margin-top: auto;
}

.btn__icon {
  display: inline-flex;
  width: 1.25rem;
  height: 1.25rem;
  align-items: center;
  justify-content: center;
  border-radius: 0.5rem;
  font-weight: 600;
  font-size: 0.95rem;
  line-height: 1;
}

.btn--add-loot {
  display: inline-flex;
  align-items: center;
  gap: 0.45rem;
  padding: 0.4rem 0.85rem;
  border-color: rgba(59, 130, 246, 0.6);
  color: #bfdbfe;
  background: linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(14, 165, 233, 0.2));
  box-shadow: inset 0 0 0 1px rgba(59, 130, 246, 0.25);
}

.btn--add-loot:hover {
  border-color: rgba(59, 130, 246, 0.85);
  color: #e0f2fe;
  background: linear-gradient(135deg, rgba(59, 130, 246, 0.3), rgba(14, 165, 233, 0.35));
}

.btn--add-loot .btn__icon {
  display: inline-flex;
  width: 22px;
  height: 22px;
  align-items: center;
  justify-content: center;
  border-radius: 0.6rem;
  background: rgba(14, 165, 233, 0.35);
  color: #fff;
  font-size: 1rem;
  line-height: 1;
  box-shadow: 0 0 8px rgba(14, 165, 233, 0.25);
}

.btn--modal-primary {
  display: inline-flex;
  align-items: center;
  gap: 0.4rem;
  background: linear-gradient(135deg, rgba(34, 197, 94, 0.8), rgba(16, 185, 129, 0.9));
  border: none;
  color: #ecfccb;
  box-shadow: 0 12px 30px rgba(16, 185, 129, 0.35);
}

.btn--modal-primary:hover {
  background: linear-gradient(135deg, rgba(74, 222, 128, 0.9), rgba(16, 185, 129, 1));
  color: #fff;
}

.btn--detected {
  background: linear-gradient(135deg, rgba(129, 140, 248, 0.85), rgba(147, 197, 253, 0.9));
  color: #0f172a;
  border: none;
  box-shadow: 0 12px 30px rgba(129, 140, 248, 0.35);
}

.btn--detected:hover {
  color: #020617;
  box-shadow: 0 14px 34px rgba(129, 140, 248, 0.45);
}

.btn--modal-outline {
  border-color: rgba(148, 163, 184, 0.5);
  color: #e2e8f0;
  background: rgba(15, 23, 42, 0.4);
}

.btn--modal-outline:hover {
  border-color: rgba(148, 163, 184, 0.8);
  color: #fff;
  background: rgba(30, 41, 59, 0.6);
}

.btn--modal-danger {
  border-color: rgba(248, 113, 113, 0.5);
  color: #fecaca;
  background: rgba(127, 29, 29, 0.25);
}

.btn--modal-danger:hover {
  border-color: rgba(248, 113, 113, 0.8);
  background: rgba(127, 29, 29, 0.45);
  color: #fff;
}

.window-form {
  display: flex;
  flex-direction: column;
  gap: 0.85rem;
}

.window-form__controls {
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 0.75rem;
}

.window-form__actions {
  display: flex;
  gap: 0.75rem;
}

.form__actions {
  display: flex;
  justify-content: flex-end;
  gap: 0.75rem;
}

.form__actions--single {
  justify-content: center;
}

.btn--detected-save {
  min-width: 220px;
}

.detected-card {
  text-align: center;
}

.detected-card__actions {
  display: none;
}

.detected-card__body {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  align-items: center;
}

.detected-card__buttons {
  display: flex;
  gap: 0.75rem;
  flex-wrap: wrap;
  justify-content: center;
}

.upload-mode-modal .modal__header h3 {
  margin-bottom: 0.25rem;
}

.upload-mode-options {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  gap: 1rem;
  margin-top: 1rem;
}

.upload-mode-card {
  border: 1px solid rgba(148, 163, 184, 0.3);
  border-radius: 0.75rem;
  padding: 1rem;
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  background: rgba(15, 23, 42, 0.65);
  min-height: 100%;
}

.upload-mode-card--disabled {
  opacity: 0.5;
}

.upload-mode-warning {
  margin: 0.25rem 0 0.5rem;
  padding: 0.75rem 1rem;
  border: 1px solid rgba(248, 113, 113, 0.5);
  border-radius: 0.75rem;
  background: rgba(127, 29, 29, 0.35);
  color: #fecaca;
  font-size: 0.85rem;
}

.upload-mode-button {
  width: 100%;
  border: none;
  border-radius: 0.75rem;
  padding: 0.9rem 1rem;
  display: flex;
  align-items: center;
  gap: 0.85rem;
  cursor: pointer;
  transition:
    transform 0.15s ease,
    box-shadow 0.15s ease,
    opacity 0.15s ease;
  text-align: left;
  color: inherit;
}

.upload-mode-button:disabled {
  cursor: not-allowed;
  opacity: 0.6;
  transform: none;
  box-shadow: none;
}

.upload-mode-button:not(:disabled):hover {
  transform: translateY(-2px);
  box-shadow: 0 12px 25px rgba(15, 23, 42, 0.45);
}

.upload-mode-button--primary,
.upload-mode-button--outline {
  background: linear-gradient(135deg, rgba(59, 130, 246, 0.7), rgba(14, 165, 233, 0.8));
  color: #f8fafc;
  box-shadow: 0 12px 30px rgba(14, 165, 233, 0.4);
  border: 1px solid rgba(56, 189, 248, 0.45);
  margin-top: auto;
}

.upload-mode-card--disabled .upload-mode-button--outline {
  background: rgba(30, 41, 59, 0.7);
  border: 1px dashed rgba(148, 163, 184, 0.5);
  color: #e2e8f0;
  box-shadow: none;
}

.upload-mode-button__icon {
  font-size: 1.5rem;
}

.upload-mode-button__text {
  display: flex;
  flex-direction: column;
  line-height: 1.2;
}

.upload-mode-button__text strong {
  font-size: 1rem;
}

.upload-mode-button__text small {
  font-size: 0.8rem;
  color: rgba(226, 232, 240, 0.8);
}

.clear-loot-actions {
  display: flex;
  justify-content: flex-end;
  gap: 0.75rem;
  margin-top: 1.5rem;
  flex-wrap: wrap;
}

.clear-loot-actions__button--danger {
  border-color: rgba(248, 113, 113, 0.55);
  color: #fecaca;
}

.clear-loot-actions__button--danger:hover,
.clear-loot-actions__button--danger:focus-visible {
  border-color: rgba(239, 68, 68, 0.75);
  color: #fee2e2;
  background: rgba(239, 68, 68, 0.12);
}

.clear-loot-actions__button--success {
  border-color: rgba(34, 197, 94, 0.55);
  background: linear-gradient(135deg, rgba(34, 197, 94, 0.35), rgba(16, 185, 129, 0.4));
  color: #f8fafc;
  text-shadow: none;
}

.clear-loot-actions__button--success:hover,
.clear-loot-actions__button--success:focus-visible {
  border-color: rgba(22, 163, 74, 0.75);
  background: linear-gradient(135deg, rgba(74, 222, 128, 0.65), rgba(34, 197, 94, 0.6));
  color: #f8fafc;
}

.edit-loot-form {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.edit-loot-form .form__field span {
  font-weight: 600;
}

.leave-monitor-actions {
  display: flex;
  justify-content: center;
  gap: 1rem;
  margin-top: 1.25rem;
}

.leave-monitor-button {
  min-width: 150px;
  padding: 0.85rem 1.75rem;
  font-size: 1rem;
}

.leave-monitor-button--stay {
  background: linear-gradient(135deg, rgba(34, 197, 94, 0.75), rgba(16, 185, 129, 0.85));
  border: none;
  color: #f0fdf4;
  box-shadow: 0 12px 25px rgba(16, 185, 129, 0.35);
}

.leave-monitor-button--stay:hover {
  filter: brightness(1.05);
}

.leave-monitor-button--leave {
  background: linear-gradient(135deg, rgba(248, 113, 113, 0.8), rgba(239, 68, 68, 0.9));
  border: none;
  color: #fff1f2;
  box-shadow: 0 12px 25px rgba(248, 113, 113, 0.35);
}

.leave-monitor-button--leave:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  box-shadow: none;
}

.detected-controls {
  display: flex;
  justify-content: flex-end;
  gap: 0.5rem;
  margin-bottom: 0.75rem;
}

.detected-table-wrapper {
  max-height: 420px;
  overflow-y: auto;
  border: 1px solid rgba(148, 163, 184, 0.15);
  border-radius: 0.75rem;
}

.detected-table-wrapper .loot-table {
  margin: 0;
}

.detected-table-wrapper .loot-table input {
  background: rgba(15, 23, 42, 0.7);
}

.debug-console {
  background: rgba(15, 23, 42, 0.75);
}

.debug-console__body {
  max-height: 240px;
  overflow-y: auto;
  border: 1px solid rgba(148, 163, 184, 0.2);
  border-radius: 0.75rem;
  padding: 0.75rem;
  background: rgba(15, 23, 42, 0.5);
}

.debug-console__actions {
  display: flex;
  gap: 0.5rem;
}

.debug-console__list {
  list-style: none;
  margin: 0;
  padding: 0;
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.debug-console__entry {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid rgba(148, 163, 184, 0.15);
}

.debug-console__entry:last-child {
  border-bottom: none;
  padding-bottom: 0;
}

.debug-console__timestamp {
  font-size: 0.75rem;
  color: #94a3b8;
  margin: 0;
}

.debug-console__message {
  margin: 0;
  font-weight: 600;
}

.debug-console__context {
  margin: 0;
  font-size: 0.75rem;
  background: rgba(15, 23, 42, 0.6);
  border-radius: 0.5rem;
  padding: 0.5rem;
  color: #e2e8f0;
}

.manual-form {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.manual-form__grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 0.75rem;
}

.manual-form__grid input,
.manual-form__grid textarea {
  background: rgba(15, 23, 42, 0.6);
  border: 1px solid rgba(148, 163, 184, 0.2);
  border-radius: 0.5rem;
  padding: 0.5rem;
  color: #f8fafc;
}

.modal-backdrop {
  position: fixed;
  inset: 0;
  background: rgba(15, 23, 42, 0.7);
  backdrop-filter: blur(6px);
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 2rem;
  z-index: 200;
}

.modal {
  width: min(960px, 95vw);
  max-height: 90vh;
  background: rgba(15, 23, 42, 0.96);
  border: 1px solid rgba(148, 163, 184, 0.25);
  border-radius: 1rem;
  padding: 1.5rem;
  display: flex;
  flex-direction: column;
  gap: 1rem;
  overflow: hidden;
}

.modal__header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.settings-form {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  flex: 1;
  overflow: hidden;
}

.settings-form__body {
  flex: 1;
  overflow-y: auto;
  padding-right: 0.25rem;
}

.settings-grid {
  display: grid;
  grid-template-columns: minmax(260px, 320px) minmax(0, 1fr);
  gap: 1rem;
}

.settings-grid__side,
.settings-grid__main {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.form__field {
  display: flex;
  flex-direction: column;
  gap: 0.35rem;
}

.form__field input,
.form__field textarea {
  background: rgba(15, 23, 42, 0.6);
  border: 1px solid rgba(148, 163, 184, 0.25);
  border-radius: 0.5rem;
  color: #f8fafc;
  padding: 0.5rem;
}

.settings-section {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.placeholder-panel {
  background: rgba(15, 23, 42, 0.45);
  border: 1px solid rgba(148, 163, 184, 0.2);
  border-radius: 0.9rem;
  padding: 0.85rem;
  gap: 0.5rem;
}

.placeholder-panel__header {
  display: flex;
  flex-direction: column;
  gap: 0.35rem;
}

.section-heading {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 0.5rem;
}

.section-heading--stacked {
  flex-wrap: wrap;
  align-items: flex-start;
}

.placeholder-toolbar {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
  align-items: flex-start;
  padding: 0.75rem 1rem;
  border: 1px solid rgba(148, 163, 184, 0.2);
  border-radius: 0.75rem;
  background: rgba(15, 23, 42, 0.5);
}

.placeholder-toolbar__label {
  min-width: 180px;
}

.placeholder-toolbar__chips {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
  flex: 1;
}

.placeholder-chip {
  display: flex;
  flex-direction: column;
  gap: 0.15rem;
  border: 1px solid rgba(59, 130, 246, 0.5);
  border-radius: 0.65rem;
  padding: 0.5rem 0.85rem;
  background: rgba(59, 130, 246, 0.1);
  color: #e0f2fe;
  font-size: 0.85rem;
  cursor: pointer;
  min-width: 150px;
}

.placeholder-chip__token {
  font-weight: 600;
}

.placeholder-chip__text {
  font-size: 0.75rem;
  color: #bae6fd;
}

.sample-tester textarea {
  background: rgba(15, 23, 42, 0.6);
  border: 1px dashed rgba(59, 130, 246, 0.4);
  border-radius: 0.5rem;
  padding: 0.6rem;
  color: #f8fafc;
}

.pattern-card {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  padding: 0.75rem;
  border: 1px solid rgba(148, 163, 184, 0.2);
  border-radius: 0.75rem;
  background: rgba(15, 23, 42, 0.4);
}

.pattern-card--empty {
  align-items: flex-start;
  text-align: left;
  gap: 0.75rem;
}

.pattern-card--active {
  border-color: rgba(59, 130, 246, 0.8);
  box-shadow: 0 0 0 1px rgba(59, 130, 246, 0.5);
}

.pattern-card--collapsed .pattern-card__body {
  display: none;
}

.pattern-list {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.pattern-card__helper {
  display: flex;
  gap: 0.5rem;
  align-items: center;
  flex-wrap: wrap;
}

.pattern-card__helper-label {
  font-size: 0.75rem;
  font-weight: 600;
  color: #cbd5f5;
}

.pattern-card__helper-content {
  display: flex;
  flex-wrap: wrap;
  gap: 0.35rem;
}

.pattern-method-ignore {
  margin-top: 0.75rem;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.method-input {
  display: flex;
  gap: 0.5rem;
  align-items: center;
}

.method-input__field {
  flex: 1;
  background: rgba(15, 23, 42, 0.6);
  border: 1px solid rgba(148, 163, 184, 0.4);
  border-radius: 0.6rem;
  padding: 0.45rem 0.6rem;
  color: #e2e8f0;
}

.method-pill-container {
  display: flex;
  flex-wrap: wrap;
  gap: 0.4rem;
}

.method-pill {
  display: inline-flex;
  align-items: center;
  gap: 0.3rem;
  background: rgba(59, 130, 246, 0.18);
  border: 1px solid rgba(59, 130, 246, 0.35);
  border-radius: 999px;
  padding: 0.25rem 0.55rem;
  color: #dbeafe;
  font-size: 0.75rem;
}

.method-pill__remove {
  background: transparent;
  border: none;
  color: inherit;
  cursor: pointer;
  font-size: 0.85rem;
  line-height: 1;
}

.pattern-card__header {
  display: flex;
  gap: 0.5rem;
  align-items: center;
}

.pattern-card__header-main {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  flex: 1;
}

.pattern-card__toggle {
  width: 28px;
  height: 28px;
  border-radius: 0.5rem;
  border: 1px solid rgba(148, 163, 184, 0.4);
  background: rgba(15, 23, 42, 0.6);
  color: #e2e8f0;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

.pattern-card__chevron {
  transition: transform 0.2s ease;
}

.pattern-card__chevron--rotated {
  transform: rotate(180deg);
}

.pattern-chip {
  display: inline-flex;
  align-items: center;
  gap: 0.25rem;
  padding: 0.25rem 0.6rem;
  border-radius: 999px;
  font-size: 0.75rem;
  background: rgba(59, 130, 246, 0.15);
  color: #bfdbfe;
}

.pattern-preview {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
  border: 1px dashed rgba(148, 163, 184, 0.3);
  border-radius: 0.75rem;
  padding: 0.75rem;
  background: rgba(15, 23, 42, 0.35);
}

.pattern-preview__label {
  font-size: 0.75rem;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: #94a3b8;
}

.pattern-preview__code {
  display: block;
  font-family: 'JetBrains Mono', 'SFMono-Regular', Consolas, monospace;
  font-size: 0.8rem;
  color: #f0abfc;
  word-break: break-all;
}

.pattern-test {
  border-radius: 0.65rem;
  padding: 0.65rem 0.85rem;
  background: rgba(15, 23, 42, 0.3);
  border: 1px solid rgba(148, 163, 184, 0.2);
}

.pattern-test--match {
  border-color: rgba(52, 211, 153, 0.4);
  background: rgba(16, 185, 129, 0.1);
}

.pattern-test--miss {
  border-color: rgba(248, 113, 113, 0.35);
  background: rgba(248, 113, 113, 0.08);
}

.pattern-test__header {
  display: flex;
  flex-direction: column;
  gap: 0.15rem;
}

.pattern-test__status {
  font-weight: 600;
  font-size: 0.9rem;
}

.pattern-test__list {
  list-style: none;
  padding: 0.25rem 0 0;
  margin: 0;
  display: flex;
  flex-direction: column;
  gap: 0.2rem;
  font-size: 0.85rem;
}

.pattern-test__list strong {
  font-weight: 600;
  color: #e2e8f0;
  margin-right: 0.25rem;
}

@media (max-width: 960px) {
  .settings-grid {
    grid-template-columns: 1fr;
  }
  .settings-form__body {
    padding-right: 0;
  }
}

.pattern-card__header {
  display: flex;
  gap: 0.5rem;
  align-items: center;
}

.icon-button {
  background: transparent;
  border: none;
  color: #94a3b8;
  cursor: pointer;
  padding: 0.2rem;
  border-radius: 0.4rem;
  transition:
    color 0.2s ease,
    background 0.2s ease;
}

.icon-button--delete {
  color: rgba(248, 113, 113, 0.8);
}

.icon-button--delete:hover,
.icon-button--delete:focus-visible {
  color: rgba(248, 113, 113, 1);
  background: rgba(248, 113, 113, 0.15);
}

.sr-only {
  position: absolute;
  left: -9999px;
}
</style>
.detected-controls { display: flex; justify-content: flex-end; gap: 0.75rem; margin-bottom: 0.75rem;
} .detected-control { display: inline-flex; align-items: center; gap: 0.4rem; font-weight: 600; }
.detected-control--keep { background: linear-gradient(135deg, rgba(34, 197, 94, 0.85), rgba(16, 185,
129, 0.9)); border: none; color: #f0fdf4; box-shadow: 0 10px 18px rgba(16, 185, 129, 0.35); }
.detected-control--discard { background: linear-gradient(135deg, rgba(248, 113, 113, 0.85),
rgba(239, 68, 68, 0.9)); border: none; color: #fff1f2; box-shadow: 0 10px 18px rgba(248, 113, 113,
0.35); } .detected-control:disabled { opacity: 0.6; cursor: not-allowed; box-shadow: none; }
.detected-save-button { min-width: 240px; font-size: 1rem; padding: 0.85rem 1.75rem; background:
linear-gradient(135deg, rgba(59, 130, 246, 0.9), rgba(14, 165, 233, 0.95)); border: none; color:
#eff6ff; box-shadow: 0 12px 28px rgba(14, 165, 233, 0.35); } .detected-save-button:disabled {
opacity: 0.6; cursor: not-allowed; box-shadow: none; }
